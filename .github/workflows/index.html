<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bivalve, NJ — Tidal Flooding Dashboard</title>

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <style>
    :root{
      --bg:#0b1220;
      --text:#eaf0ff;
      --muted:#a9b6d3;
      --line:rgba(255,255,255,.085);
      --ok:#2dd4bf;
      --minor:#fbbf24;
      --moderate:#fb7185;
      --major:#a78bfa;
      --shadow:0 22px 70px rgba(0,0,0,.40);
      --radius:18px;

      /* NO “glow” backgrounds at all (removes greenish banding on iOS) */
      --card:rgba(255,255,255,.035);
      --card2:rgba(0,0,0,.18);
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    html{background:var(--bg);}
    body{
      margin:0;
      font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      background:var(--bg);   /* solid only */
      color:var(--text);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      overflow-x:hidden;
    }
    /* KILL any old global overlay gradient */
    body:before{content:none !important;}

    .wrap{max-width:1200px;margin:0 auto;padding:16px 16px 28px}
    a{color:inherit;text-decoration:none}
    canvas{display:block;max-width:100%}

    .banner{
      display:none;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(251,113,133,.12);
      border-radius:14px;
      padding:12px 12px;
      margin-bottom:12px;
      box-shadow:var(--shadow);
    }
    .banner b{font-weight:950}
    .banner .small{color:var(--muted);font-size:12.5px;margin-top:4px;line-height:1.25}

    .top{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px}
    .brand{display:flex;align-items:center;gap:12px}
    .brand img{width:44px;height:44px;border-radius:12px;border:1px solid var(--line);background:rgba(0,0,0,.25)}
    .brandTitle{display:flex;flex-direction:column;line-height:1.1}
    .kicker{color:var(--muted);font-weight:850;font-size:12px;letter-spacing:.2px;text-transform:uppercase}
    .name{font-size:18px;font-weight:950;letter-spacing:.2px}

    .pill{
      display:flex;align-items:center;gap:10px;
      padding:10px 12px;border-radius:999px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.16);
      box-shadow:var(--shadow);
      font-weight:950;font-size:12.5px;white-space:nowrap;
    }
    .dot{width:9px;height:9px;border-radius:999px;background:var(--ok);box-shadow:0 0 0 4px rgba(45,212,191,.16)}

    /* --- Mobile header overflow fix (kept) --- */
    .brand, .brandTitle { min-width: 0; }
    .kicker, .name { min-width: 0; }
    .kicker, .name{
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    #lastPill, #stagePill, #datumBtn{ min-width:0; }
    .pill{ max-width:100%; overflow:hidden; text-overflow:ellipsis; }

    @media (max-width: 720px){
      .top{
        flex-direction:column;
        align-items:center;
        justify-content:center;
        gap:10px;
        text-align:center;
      }
      .brand{ width:100%; justify-content:center; text-align:center; }
      .brandTitle{ align-items:center; text-align:center; }
      .kicker, .name{
        white-space:normal;
        overflow:visible;
        text-overflow:clip;
      }
      .top > div{
        width:100%;
        justify-content:center !important;
        flex-wrap:wrap;
      }
      .pill, .btn{ max-width:100%; }
    }

    .grid{display:grid;grid-template-columns:1.15fr .85fr;gap:14px;margin-top:10px}
    @media(max-width:980px){.grid{grid-template-columns:1fr}}

    .card{
      background:var(--card);        /* flat */
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:14px;
      overflow:hidden;
      position:relative;

      /* keep iOS hardening, but NO overlay gradients */
      isolation:isolate;
      contain:paint;
      transform:translateZ(0);
      -webkit-transform:translateZ(0);
    }
    /* KILL glow overlays inside cards */
    .card:before{content:none !important;}
    .card>*{position:relative;z-index:1}

    .hrow{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
    }
    .hrow h2{margin:0;font-size:12.5px;letter-spacing:.22px;text-transform:uppercase;color:var(--muted);font-weight:950}

    /* ===== Live Conditions layout ===== */
    .liveGrid{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:10px;
      margin-top:8px;
    }
    @media(max-width:820px){ .liveGrid{grid-template-columns:1fr;} }

    .panel{
      background:var(--card2);
      border:1px solid var(--line);
      border-radius:14px;
      padding:12px;
      position:relative;
      overflow:hidden;
      min-height:168px;

      isolation:isolate;
      contain:paint;
      transform:translateZ(0);
      -webkit-transform:translateZ(0);
    }
    /* KILL glow overlays inside panels */
    .panel:before{content:none !important;}
    .panel>*{position:relative;z-index:1}

    .panelTitle{
      color:var(--muted);
      font-weight:950;
      font-size:11.5px;
      text-transform:uppercase;
      letter-spacing:.2px;
      text-align:center;
      margin-bottom:10px;
    }

    /* TODAY */
    .todayTop{
      display:flex;
      align-items:stretch;
      justify-content:center;
      gap:12px;
      flex-wrap:wrap;
    }

    .curBox{
      flex:1 1 260px;
      min-width:260px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.14);
      border-radius:14px;
      padding:10px 12px;
      text-align:center;
    }
    .curLabel{
      color:var(--muted);
      font-weight:950;
      font-size:11px;
      text-transform:uppercase;
      letter-spacing:.2px;
      text-align:center;
    }
    .curRow{
      display:flex;
      align-items:baseline;
      justify-content:center;
      gap:10px;
      margin-top:8px;
    }
    .curVal{
      display:flex;
      align-items:baseline;
      justify-content:center;
      gap:8px;
      font-weight:950;
      font-size:28px;
      letter-spacing:.2px;
      white-space:nowrap;
    }
    .curMeta{
      margin-top:8px;
      color:var(--muted);
      font-size:12.5px;
      line-height:1.25;
      text-align:center;
      display:none;
    }

    /* remove progress bar under Current water elevation */
    .levelMeter{display:none !important;}
    .levelFill{display:none !important;}

    .todayRange{
      flex:0 0 320px;
      min-width:260px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.14);
      border-radius:14px;
      padding:10px 12px;
      text-align:center;
      display:flex;
      flex-direction:column;
      justify-content:center;
    }
    .rangeRow{display:flex;justify-content:center;gap:18px;flex-wrap:wrap;margin-top:6px}
    .rangeCol{min-width:140px}
    .rangeLab{color:var(--muted);font-weight:950;font-size:11px;letter-spacing:.18px;text-transform:uppercase;text-align:center}
    .rangeVal{font-weight:950;font-size:34px;line-height:1;margin-top:6px;white-space:nowrap;text-align:center}
    .unit{color:var(--muted);font-size:12px;font-weight:950}
    .rangeMeta{
      margin-top:10px;
      color:var(--muted);
      font-size:12px;
      line-height:1.25;
      text-align:center;
      display:none;
    }

    @media(max-width:520px){
      .rangeVal{font-size:32px}
      .curVal{font-size:26px}
    }

    /* OUTLOOK */
    .outlookTop{
      display:grid;
      grid-template-columns:repeat(3, minmax(0, 1fr));
      gap:10px;
      align-items:stretch;
      justify-items:stretch;
      margin-bottom:10px;
    }
    @media(max-width:520px){
      .outlookTop{grid-template-columns:1fr;}
    }

    .miniStat{
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      padding:12px 12px;
      border-radius:14px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.05);
      font-weight:950;
      font-size:12.5px;
      white-space:nowrap;
      text-align:center;
      min-height:52px;
      width:100%;
    }
    .miniChip{width:12px;height:12px;border-radius:99px;display:inline-block}
    .miniStat b{font-weight:950}

    .events{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-top:6px;
    }
    .event{
      border:1px solid var(--line);
      background:rgba(0,0,0,.14);
      border-radius:14px;
      padding:10px 10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .eventLeft{
      display:flex;
      flex-direction:column;
      gap:2px;
      min-width:0;
    }
    .eventWhen{
      font-weight:950;
      font-size:13px;
      letter-spacing:.1px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .eventSub{
      color:var(--muted);
      font-size:12px;
      line-height:1.2;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .eventBadge{
      font-weight:950;
      font-size:12px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.06);
      white-space:nowrap;
      flex:0 0 auto;
    }
    @media(max-width:520px){
      .event{align-items:flex-start}
      .eventWhen,.eventSub{white-space:normal}
      .eventBadge{margin-left:auto}
    }

    /* Flood stage strip (stack on mobile so nothing goes off-screen) */
    .stages{
      display:grid;
      grid-template-columns:repeat(3, minmax(0, 1fr));
      gap:10px;
      margin-top:10px;
    }
    @media(max-width:520px){
      .stages{grid-template-columns:1fr;}
    }

    .stage{
      background:var(--card2);
      border:1px solid var(--line);
      border-radius:14px;
      padding:16px 14px;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:12px;
      width:100%;
      overflow:hidden;
      text-align:center;
    }
    .stageName{
      font-weight:950;
      font-size:20px;
      letter-spacing:.2px;
      width:100%;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      text-align:center;
    }
    .badge{
      font-weight:950;
      font-size:13px;
      padding:10px 14px;
      border-radius:999px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.06);
      white-space:nowrap;
      text-align:center;
    }

    .table{border-radius:14px;overflow:hidden;border:1px solid var(--line);background:var(--card2)}
    table{width:100%;border-collapse:collapse}
    th,td{padding:10px 10px;border-bottom:1px solid var(--line);font-size:13px}
    th{text-align:left;color:var(--muted);text-transform:uppercase;letter-spacing:.2px;font-size:11px;font-weight:950}
    tr:last-child td{border-bottom:none}

    .tag{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;border:1px solid var(--line);background:rgba(255,255,255,.05);font-weight:950;font-size:12px;white-space:nowrap}
    .chip{width:9px;height:9px;border-radius:99px;display:inline-block}

    .chartWrapTall{height:320px;width:100%}
    .chartWrap{height:240px;width:100%}
    .foot{margin-top:10px;color:var(--muted);font-size:12.5px;line-height:1.25;text-align:center}

    .filterRow{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-bottom:10px}
    .input,.btn,select{
      background:rgba(0,0,0,.18);
      border:1px solid var(--line);
      color:var(--text);
      border-radius:12px;
      padding:10px 10px;
      font-weight:950;
      font-size:13px;
      outline:none
    }
    .input{min-width:240px}
    .btn{cursor:pointer}
    .btn:hover{filter:brightness(1.06)}
    .hint{color:var(--muted);font-size:12.5px;line-height:1.25}

    .btn:focus,.input:focus,select:focus{
      border-color:rgba(45,212,191,.35);
      box-shadow:0 0 0 4px rgba(45,212,191,.10);
    }

    /* Hide footer notes you called out */
    #f48Meta{display:none !important;}
    #curMeta{display:none !important;}
  </style>
</head>

<body>
  <div class="wrap">

    <div class="banner" id="alertBanner">
      <div><b id="alertTitle">Coastal Flood Advisory</b></div>
      <div class="small" id="alertBody"></div>
    </div>

    <div class="top">
      <a class="brand" href="https://cupajoe.live/" target="_blank" rel="noopener">
        <img src="assets/cupajoe-logo.png" alt="Cupajoe logo">
        <div class="brandTitle">
          <div class="kicker">USGS 01412150 · Maurice River at Bivalve, NJ</div>
          <div class="name">Bivalve Tidal Flooding Dashboard</div>
        </div>
      </a>

      <div style="display:flex;align-items:center;justify-content:flex-end;gap:10px;flex-wrap:wrap">
        <button class="btn" id="datumBtn" title="Flip between MLLW and NAVD88">Datum: MLLW</button>
        <div class="pill" id="lastPill">Last updated: —</div>
        <div class="pill" id="stagePill">
          <span class="dot" id="stageDot"></span>
          <span id="stageText">Loading…</span>
        </div>
      </div>
    </div>

    <!-- 1) Live Conditions -->
    <div class="card">
      <div class="hrow">
        <h2>Live conditions</h2>
        <div class="kicker" style="text-transform:none">Time Expressed In EST</div>
      </div>

      <div class="liveGrid">
        <!-- TODAY (current + today's max/min) -->
        <div class="panel">
          <div class="panelTitle">Daily range (today)</div>

          <div class="todayTop">
            <div class="curBox">
              <div class="curLabel">Current water elevation</div>

              <div class="curRow">
                <div class="curVal">
                  <span id="curFt">—</span>
                  <span class="unit" data-unit>ft MLLW</span>
                </div>
              </div>

              <div class="levelMeter" aria-hidden="true">
                <div class="levelFill" id="curFill"></div>
              </div>

              <div class="curMeta" id="curMeta">Updated: —</div>
              <div class="curMeta" id="nearMeta" style="display:none"></div>
            </div>

            <div class="todayRange">
              <div class="rangeRow">
                <div class="rangeCol">
                  <div class="rangeLab">Max</div>
                  <div class="rangeVal">
                    <span id="dayMaxFt">—</span>
                    <span class="unit" data-unit>ft MLLW</span>
                  </div>
                </div>
                <div class="rangeCol">
                  <div class="rangeLab">Min</div>
                  <div class="rangeVal">
                    <span id="dayMinFt">—</span>
                    <span class="unit" data-unit>ft MLLW</span>
                  </div>
                </div>
              </div>

              <div class="rangeMeta" id="dayRangeMeta">—</div>
            </div>
          </div>
        </div>

        <!-- NEXT 48H FLOOD OUTLOOK -->
        <div class="panel">
          <div class="panelTitle">Flood outlook (next 48h)</div>

          <div class="outlookTop" aria-label="Total flood hours by type">
            <div class="miniStat">
              <span class="miniChip" style="background:var(--minor)"></span>
              Minor <b id="f48MinorHrs">—</b> hrs
            </div>
            <div class="miniStat">
              <span class="miniChip" style="background:var(--moderate)"></span>
              Moderate <b id="f48ModerHrs">—</b> hrs
            </div>
            <div class="miniStat">
              <span class="miniChip" style="background:var(--major)"></span>
              Major <b id="f48MajorHrs">—</b> hrs
            </div>
          </div>

          <div class="events" id="f48List">
            <div class="event">
              <div class="eventLeft">
                <div class="eventWhen">Loading…</div>
                <div class="eventSub">—</div>
              </div>
              <div class="eventBadge" style="color:var(--muted)">—</div>
            </div>
          </div>

          <div class="rangeMeta" id="f48Meta">—</div>
        </div>
      </div>

      <div class="stages" aria-label="Flood stages">
        <div class="stage">
          <div class="stageName">Minor</div>
          <div class="badge" id="minorBadge" style="color:var(--minor)">7.60–8.60</div>
        </div>
        <div class="stage">
          <div class="stageName">Moderate</div>
          <div class="badge" id="moderateBadge" style="color:var(--moderate)">8.60–9.60</div>
        </div>
        <div class="stage">
          <div class="stageName">Major</div>
          <div class="badge" id="majorBadge" style="color:var(--major)">≥ 9.60</div>
        </div>
      </div>
    </div>

    <div style="height:14px"></div>

    <!-- 2) Top 10 Highest Tides -->
    <div class="card" style="display:flex;flex-direction:column">
      <div class="hrow"><h2>Top ten highest tides</h2></div>
      <div class="table" style="flex:1 1 auto">
        <table aria-label="Top ten highest tides">
          <thead>
            <tr>
              <th>Rank</th>
              <th>Date</th>
              <th id="topTenUnitTh">Height (ft MLLW)</th>
              <th>Type</th>
            </tr>
          </thead>
          <tbody id="topTenBody"></tbody>
        </table>
      </div>
    </div>

    <div style="height:14px"></div>

    <!-- 3) Observations & Predictions -->
    <div class="card">
      <div class="hrow">
        <h2>Observations (USGS) & Predictions (NOAA)</h2>
        <div class="kicker" style="text-transform:none"></div>
      </div>

      <div class="chartWrapTall">
        <canvas id="tsChart"></canvas>
      </div>

      <div class="foot" id="threshKey" style="font-size:18px;">
        <span class="tag" style="padding:10px 16px;">
          <span class="chip" style="background:var(--minor); width:14px; height:14px;"></span>
          Minor
        </span>
        <span class="tag" style="padding:10px 16px;">
          <span class="chip" style="background:var(--moderate); width:14px; height:14px;"></span>
          Moderate
        </span>
        <span class="tag" style="padding:10px 16px;">
          <span class="chip" style="background:var(--major); width:14px; height:14px;"></span>
          Major
        </span>
      </div>

      <div class="foot" id="fcNote"></div>
      <div class="foot" id="txtNote"></div>
    </div>

    <div style="height:14px"></div>

    <!-- 4) Average Floods Per Month -->
    <div class="card">
      <div class="hrow"><h2>Average Number of floods per month</h2></div>
      <div class="hint" id="monthAvgMeta">Computing…</div>
      <div style="height:10px"></div>
      <div class="chartWrap"><canvas id="monthAvgChart"></canvas></div>
      <div style="height:10px"></div>
      <div class="table">
        <table aria-label="Average floods by month of year">
          <thead>
            <tr>
              <th>Month</th>
              <th>Avg Total</th>
              <th>Avg Minor</th>
              <th>Avg Moderate</th>
              <th>Avg Major</th>
            </tr>
          </thead>
          <tbody id="monthAvgBody"></tbody>
        </table>
      </div>
    </div>

    <div style="height:14px"></div>

    <!-- 5) Flooding over the years bar chart -->
    <div class="card">
      <div class="hrow">
        <h2>Flooding over the years</h2>
        <div class="kicker" style="text-transform:none"></div>
      </div>
      <div class="chartWrap"><canvas id="annualChart"></canvas></div>
      <div class="foot" id="annualNote"></div>
    </div>

    <div style="height:14px"></div>

    <!-- 6) Historic Flooding Filter -->
    <div class="card">
      <div class="hrow"><h2>Historic Flooding Filter (enter a range)</h2></div>
      <div class="filterRow">
        <input class="input" id="minElev" type="number" step="0.01" placeholder="Min (ft)" />
        <input class="input" id="maxElev" type="number" step="0.01" placeholder="Max (ft)" />
        <input class="input" id="fromDate" type="date" autocomplete="off" />
        <input class="input" id="toDate" type="date" autocomplete="off" />
        <select id="sortMode">
          <option value="desc">Highest first</option>
          <option value="asc">Lowest first</option>
          <option value="recent">Most recent</option>
        </select>
        <button class="btn" id="applyBtn">Apply</button>
        <button class="btn" id="resetBtn">Reset</button>
      </div>
      <div class="hint" id="histMeta">Loading…</div>
      <div style="height:10px"></div>
      <div class="table">
        <table aria-label="Historic tides above threshold">
          <thead>
            <tr>
              <th>Date/Time (EST)</th>
              <th id="histUnitTh">Peak (ft MLLW)</th>
              <th>Type</th>
            </tr>
          </thead>
          <tbody id="histBody"></tbody>
        </table>
      </div>
    </div>

    <div style="height:14px"></div>

    <!-- 7) Cumulative flooding by day-of-year (Avg + Min/Max band) -->
    <div class="card">
      <div class="hrow">
        <h2>Cumulative annual flooding</h2>
        <div class="kicker" id="doyMeta">Computing…</div>
      </div>

      <div class="hint" id="doyHint"></div>

      <div style="height:10px"></div>
      <div class="chartWrapTall"><canvas id="doyCumChart"></canvas></div>

      <div class="foot" id="doyNote"></div>
    </div>

    <div style="height:14px"></div>

  </div>


    <script>
/* Fixed EST year-round (UTC-5). */
const TZ="Etc/GMT+5";

/* Datum toggle */
let DISPLAY_DATUM = "MLLW"; // "MLLW" or "NAVD88"

const NAVD_MINUS_MLLW_FT = -3.41;           // NAVD = MLLW - 3.41
function mllwToNavd(ft){ return ft + NAVD_MINUS_MLLW_FT; }  // mllw - 3.41
function navdToMllw(ft){ return ft - NAVD_MINUS_MLLW_FT; }  // navd + 3.41

/* USGS observed (15-min IV). */
const USGS_SITE="01412150";

/* Water level ONLY (tide elevation NAVD88). */
const USGS_PARAM_PRIMARY = "72279";

/* NOAA CO-OPS predictions */
const COOPS_STATION="8535055";
const COOPS_APP="cupajoe.live";
const COOPS_DATUM="MLLW";
const COOPS_INTERVAL="6";
const COOPS_TZ="gmt";

      /* Tide-clock settings for crest-anchored highs (NOAA hilo predictions) */
const NOAA_STATION_TIDECLOCK = "8535055"; // same station as COOPS_STATION (Bivalve)
const CREST_WINDOW_HOURS = 2;             // search max within ±2 hours of predicted crest
const REQUIRE_WITHIN_HOURS = 1;           // must have at least one obs point within ±1 hour


/* Flood thresholds */
const THRESH = {
  MLLW: { minorLow:7.60, moderateLow:8.60, majorLow:9.60 },
  NAVD88:{ minorLow:4.19, moderateLow:5.19, majorLow:6.19 }
};

      const HOUR_MS = 60 * 60 * 1000;

function floorToHourMs(tMs){
  return Math.floor(tMs / HOUR_MS) * HOUR_MS;
}

function buildHourlyLabels(startISO, endISO){
  const start = floorToHourMs(new Date(startISO).getTime());
  const end   = floorToHourMs(new Date(endISO).getTime());
  const labels = [];
  for(let t = start; t <= end; t += HOUR_MS){
    labels.push(new Date(t).toISOString());
  }
  return labels;
}

// Pick the LAST value observed within each hour (looks best for water level)
function seriesToHourlyLast(series){
  const m = new Map(); // hourMs -> ft
  for(const p of (series || [])){
    const tMs = new Date(p.t).getTime();
    const ft  = Number(p.ft);
    if(!Number.isFinite(tMs) || !Number.isFinite(ft)) continue;
    m.set(floorToHourMs(tMs), ft); // later points overwrite earlier => "last in hour"
  }
  return m;
}

// Snap a series to the hourly labels (no interpolation, just exact hour hits)
function mapToHourlyValues(labels, hourMap){
  return labels.map(iso=>{
    const h = floorToHourMs(new Date(iso).getTime());
    return hourMap.has(h) ? hourMap.get(h) : null;
  });
}


/* Peak counting settings */
const PEAK_MIN_SEP_MINUTES = 300;

      /* Historic filter: switch to live after this date */
const LIVE_START_ISO = "2026-01-01T00:00:00Z"; // use >= Jan 1 2026



/* NWS alerts point */
const ALERT_POINT={lat:39.2325, lon:-75.0380};

/* TXT daily tides file */
const DAILY_TIDES_TXT_FILE = "bivalve_daily_stats.txt";
const TXT_PATH_CANDIDATES = [
  `data/${DAILY_TIDES_TXT_FILE}`,
  `./data/${DAILY_TIDES_TXT_FILE}`,
  `../data/${DAILY_TIDES_TXT_FILE}`,
  `/data/${DAILY_TIDES_TXT_FILE}`
];
let DAILY_TIDES_TXT_URL = TXT_PATH_CANDIDATES[0];


/* TXT columns (NAVD88 daily stats for parameter 72279) */
const COL_DAILY_HIGH = "239251_72279_00021";
const COL_DAILY_LOWHI = "239252_72279_00022";

/* Top ten list (MLLW) — FIXED (shifted +3.41 ft from NAVD) */
const TOP_TEN_MLLW = [
  {date:"10-29-2012", ft:10.44},
  {date:"11-25-1950", ft:10.01},
  {date:"04-16-2011", ft:9.21},
  {date:"08-04-2020", ft:9.08},
  {date:"08-27-2011", ft:9.01},
  {date:"01-23-2016", ft:8.99},
  {date:"04-19-2022", ft:8.91},
  {date:"08-21-2025", ft:8.90},
  {date:"10-26-2018", ft:8.82},
  {date:"03-09-2024", ft:8.80}
];

/* DOM */
const $=id=>document.getElementById(id);

const curFtEl=$("curFt"), curMetaEl=$("curMeta");
const dayMaxFtEl=$("dayMaxFt"), dayMinFtEl=$("dayMinFt"), dayRangeMeta=$("dayRangeMeta");
const stageTextEl=$("stageText"), stageDotEl=$("stageDot");
const lastPill=$("lastPill");
const alertBanner=$("alertBanner"), alertTitle=$("alertTitle"), alertBody=$("alertBody");

const topTenBody=$("topTenBody");
const topTenUnitTh=$("topTenUnitTh");
const fcNote=$("fcNote");
const txtNote=$("txtNote");

const histBody = $("histBody"),
      histMeta = $("histMeta"),
      histUnitTh = $("histUnitTh");

const minElevEl  = $("minElev"),
      maxElevEl  = $("maxElev"),
      fromDateEl = $("fromDate"),
      toDateEl   = $("toDate"),
      sortModeEl = $("sortMode");

const minorBadge = $("minorBadge"),
      moderateBadge = $("moderateBadge"),
      majorBadge = $("majorBadge");

const datumBtn = $("datumBtn");
      // Flood outlook (next 48h) DOM
const f48MinorHrsEl = $("f48MinorHrs");
const f48ModerHrsEl = $("f48ModerHrs");
const f48MajorHrsEl = $("f48MajorHrs");
const f48ListEl     = $("f48List");
const f48MetaEl     = $("f48Meta");



const monthAvgMeta=$("monthAvgMeta"), monthAvgBody=$("monthAvgBody");

/* If ANY JS error happens, show it in the UI so you’re not blind */
window.addEventListener("error",(e)=>{
  console.error("JS error:", e?.message || e);
  stageTextEl.textContent="SCRIPT ERROR (open Console)";
});
window.addEventListener("unhandledrejection",(e)=>{
  console.error("Unhandled promise:", e?.reason || e);
  stageTextEl.textContent="SCRIPT ERROR (open Console)";
});

/* Formatters */
const fmtFull = new Intl.DateTimeFormat("en-US",{ timeZone:TZ,year:"numeric",month:"short",day:"2-digit", hour:"2-digit",minute:"2-digit",hour12:true });
const fmtDay = new Intl.DateTimeFormat("en-US",{timeZone:TZ,month:"short",day:"2-digit"});
const fmtPartsYMD = new Intl.DateTimeFormat("en-US",{timeZone:TZ,year:"numeric",month:"2-digit",day:"2-digit"});
const fmtMonthName = new Intl.DateTimeFormat("en-US",{timeZone:TZ,month:"short"});

      const fmtTime = new Intl.DateTimeFormat("en-US", {
  timeZone: TZ,
  hour: "2-digit",
  minute: "2-digit",
  hour12: true
});
function fmtESTTime(iso){ return fmtTime.format(new Date(iso)); }

function fmtESTFull(iso){ return fmtFull.format(new Date(iso)); }
function fmtESTDay(iso){ return fmtDay.format(new Date(iso)); }
function fmtNiceDate(iso){
  const d = new Date(iso);
  if(Number.isNaN(d.getTime())) return "";
  const parts = new Intl.DateTimeFormat("en-US", {
    timeZone: TZ,
    year: "numeric",
    month: "short",
    day: "numeric"
  }).formatToParts(d);

  const month = parts.find(p=>p.type==="month")?.value || "";
  const dayN  = + (parts.find(p=>p.type==="day")?.value || "0");
  const year  = parts.find(p=>p.type==="year")?.value || "";

  const suffix =
    (dayN % 100 >= 11 && dayN % 100 <= 13) ? "th" :
    (dayN % 10 === 1) ? "st" :
    (dayN % 10 === 2) ? "nd" :
    (dayN % 10 === 3) ? "rd" : "th";

  return `${month} ${dayN}${suffix} ${year}`;
}

function getESTParts(date=new Date()){
  const p=fmtPartsYMD.formatToParts(date);
  return { y:+p.find(x=>x.type==="year").value, m:+p.find(x=>x.type==="month").value, d:+p.find(x=>x.type==="day").value };
}

function startOfTodayEST_ISO(){
  const {y,m,d}=getESTParts(new Date());
  return new Date(Date.UTC(y,m-1,d,5,0,0)).toISOString();
}
function startOfYearEST_ISO(y){ return new Date(Date.UTC(y,0,1,5,0,0)).toISOString(); }
function nowISO(){ return new Date().toISOString(); }

/* Datum helpers */
function datumLabel(){ return DISPLAY_DATUM; }
function unitText(){ return "ft " + datumLabel(); }
function toDisplayFtFromNavd(navd){ return (DISPLAY_DATUM==="MLLW") ? navdToMllw(navd) : navd; }
function toDisplayFtFromMllw(mllw){ return (DISPLAY_DATUM==="MLLW") ? mllw : mllwToNavd(mllw); }
function fromDisplayToNavd(displayFt){ return (DISPLAY_DATUM==="MLLW") ? mllwToNavd(displayFt) : displayFt; }

/* Stage classify uses NAVD thresholds */
function classifyByNavd(navdFt){
  const T = THRESH.NAVD88;
  if(navdFt>=T.majorLow) return {label:"MAJOR FLOODING", color:"var(--major)", glow:"rgba(167,139,250,.22)", short:"Major"};
  if(navdFt>=T.moderateLow) return {label:"MODERATE FLOODING", color:"var(--moderate)", glow:"rgba(251,113,133,.22)", short:"Moderate"};
  if(navdFt>=T.minorLow) return {label:"MINOR FLOODING", color:"var(--minor)", glow:"rgba(251,191,36,.22)", short:"Minor"};
  return {label:"BELOW FLOOD STAGE", color:"var(--ok)", glow:"rgba(45,212,191,.18)", short:"Below"};
}
function stageTagByNavd(navdFt){
  const c=classifyByNavd(navdFt);
  return {txt:c.short, c:c.color};
}
function setStage(navdFt){
  const c=classifyByNavd(navdFt);
  stageTextEl.textContent=c.label;
  stageDotEl.style.background=c.color;
  stageDotEl.style.boxShadow = `0 0 0 4px ${c.glow}`;
}

function updateUnitsAndBadges(){
  document.querySelectorAll("[data-unit]").forEach(el=>{ el.textContent = "ft " + datumLabel(); });
  topTenUnitTh.textContent = "Height (" + unitText() + ")";
  histUnitTh.textContent = "Peak (" + unitText() + ")";

  const T = THRESH[DISPLAY_DATUM];
  minorBadge.textContent = `${T.minorLow.toFixed(2)}–${T.moderateLow.toFixed(2)}`;
  moderateBadge.textContent = `${T.moderateLow.toFixed(2)}–${T.majorLow.toFixed(2)}`;
  majorBadge.textContent = `≥ ${T.majorLow.toFixed(2)}`;

  datumBtn.textContent = "Datum: " + datumLabel();
}

/* Simple helpers */
function maxPoint(arr){ return arr.reduce((a,b)=>b.ft>a.ft?b:a, arr[0]); }
function minPoint(arr){ return arr.reduce((a,b)=>b.ft<a.ft?b:a, arr[0]); }
function setTXTStatus(msg){ if(txtNote) txtNote.textContent = msg || ""; }
      function thresholdsDisplay(){
  const T = THRESH[DISPLAY_DATUM];
  return { minor:T.minorLow, moderate:T.moderateLow, major:T.majorLow };
}

      function stageNameFromDisplayFt(ft){
  const T = THRESH[DISPLAY_DATUM];
  if(ft >= T.majorLow) return "Major";
  if(ft >= T.moderateLow) return "Moderate";
  if(ft >= T.minorLow) return "Minor";
  return "Below";
}

function stageColorVar(stage){
  if(stage==="Major") return "var(--major)";
  if(stage==="Moderate") return "var(--moderate)";
  if(stage==="Minor") return "var(--minor)";
  return "var(--muted)";
}

// Build segments of consecutive points where stage >= Minor
function buildFloodSegments(points){
  const segs = [];
  let cur = null;

  for(const p of points){
    const stage = stageNameFromDisplayFt(p.ftDisplay);

    if(stage === "Below"){
      if(cur){ segs.push(cur); cur = null; }
      continue;
    }

    if(!cur){
      cur = { startT:p.t, endT:p.t, peakFt:p.ftDisplay, peakStage:stage, startMs:p.ms, endMs:p.ms };
    }else{
      cur.endT = p.t;
      cur.endMs = p.ms;
      if(p.ftDisplay > cur.peakFt){
        cur.peakFt = p.ftDisplay;
        cur.peakStage = stage;
      }
    }
  }
  if(cur) segs.push(cur);
  return segs;
}

function updateFloodOutlook48(){
  if(!f48MinorHrsEl || !f48ModerHrsEl || !f48MajorHrsEl || !f48ListEl || !f48MetaEl) return;

  const pred = STATE.pred72Mllw || [];
  if(!pred.length){
    f48MinorHrsEl.textContent = "—";
    f48ModerHrsEl.textContent = "—";
    f48MajorHrsEl.textContent = "—";
    f48ListEl.innerHTML = `
      <div class="event">
        <div class="eventLeft">
          <div class="eventWhen">NOAA/PETSS unavailable</div>
          <div class="eventSub">No forecast points loaded</div>
        </div>
        <div class="eventBadge" style="color:var(--muted)">—</div>
      </div>`;
    f48MetaEl.textContent = "";
    return;
  }

  // Next 48h window anchored to forecast start
  const t0 = new Date(pred[0].t).getTime();
  const t1 = t0 + 48 * 3600 * 1000;

  // Convert to DISPLAY datum and keep only 48h
  const pts = pred
    .map(p=>{
      const ms = new Date(p.t).getTime();
      const mllw = Number(p.ft);
      if(!Number.isFinite(ms) || !Number.isFinite(mllw)) return null;
      if(ms < t0 || ms > t1) return null;
      const ftDisplay = toDisplayFtFromMllw(mllw);
      return { t: p.t, ms, ftDisplay };
    })
    .filter(Boolean)
    .sort((a,b)=>a.ms-b.ms);

  if(!pts.length){
    f48MinorHrsEl.textContent = "0.0";
    f48ModerHrsEl.textContent = "0.0";
    f48MajorHrsEl.textContent = "0.0";
    f48ListEl.innerHTML = `
      <div class="event">
        <div class="eventLeft">
          <div class="eventWhen">No flood periods forecast</div>
          <div class="eventSub">Next 48h stays below minor</div>
        </div>
        <div class="eventBadge" style="color:var(--ok)">Below</div>
      </div>`;
    f48MetaEl.textContent = `${fmtNiceDate(pred[0].t)} → ${fmtNiceDate(new Date(t1).toISOString())}`;
    return;
  }

  // Count duration in each stage using dt between points
  let minorMs=0, moderMs=0, majorMs=0;

  for(let i=0;i<pts.length;i++){
    const a = pts[i];
    const b = pts[i+1] || null;
    const dt = b ? Math.max(0, b.ms - a.ms) : 15*60*1000; // assume 15m for last step
    const stage = stageNameFromDisplayFt(a.ftDisplay);

    if(stage==="Major") majorMs += dt;
    else if(stage==="Moderate") moderMs += dt;
    else if(stage==="Minor") minorMs += dt;
  }

  const msToHours = ms => (ms / 3600000);
  f48MinorHrsEl.textContent = msToHours(minorMs).toFixed(1);
  f48ModerHrsEl.textContent = msToHours(moderMs).toFixed(1);
  f48MajorHrsEl.textContent = msToHours(majorMs).toFixed(1);

  // Build flood segments list
  const segs = buildFloodSegments(pts);

  if(!segs.length){
    f48ListEl.innerHTML = `
      <div class="event">
        <div class="eventLeft">
          <div class="eventWhen">No flood periods forecast</div>
          <div class="eventSub">Next 48h stays below minor</div>
        </div>
        <div class="eventBadge" style="color:var(--ok)">Below</div>
      </div>`;
  }else{
    const show = segs.slice(0,4);
    f48ListEl.innerHTML = show.map(seg=>{
      const durH = Math.max(0.25, (seg.endMs - seg.startMs) / 3600000);
      const when = `${fmtNiceDate(seg.startT)} · ${fmtESTTime(seg.startT)} → ${fmtESTTime(seg.endT)}`;
      const sub  = `${durH.toFixed(1)}h · Peak ${seg.peakFt.toFixed(2)} ${unitText()}`;
      const badgeColor = stageColorVar(seg.peakStage);

      return `
        <div class="event">
          <div class="eventLeft">
            <div class="eventWhen">${when}</div>
            <div class="eventSub">${sub}</div>
          </div>
          <div class="eventBadge" style="color:${badgeColor}">${seg.peakStage}</div>
        </div>`;
    }).join("");
  }

  f48MetaEl.textContent =
    `${fmtNiceDate(pred[0].t)} → ${fmtNiceDate(new Date(t1).toISOString())} · Based on NOAA/PETSS`;
}

function updatePred24RangeCard(){
  const maxEl = document.getElementById("pred24MaxFt");
  const minEl = document.getElementById("pred24MinFt");
  const metaEl = document.getElementById("pred24Meta");
  if(!maxEl || !minEl || !metaEl) return;

  const pred = STATE.pred72Mllw || [];
  if(!pred.length){
    maxEl.textContent = "—";
    minEl.textContent = "—";
    metaEl.textContent = "NOAA predictions unavailable";
    return;
  }

  const t0 = new Date(pred[0].t).getTime();
  const t1 = t0 + 24*3600*1000;

  const window = pred
    .map(p => ({ t:new Date(p.t).getTime(), ft:p.ft }))
    .filter(p => Number.isFinite(p.t) && Number.isFinite(p.ft) && p.t >= t0 && p.t <= t1);

  if(!window.length){
    maxEl.textContent = "—";
    minEl.textContent = "—";
    metaEl.textContent = "NOAA predictions empty (24h)";
    return;
  }

  let max = -Infinity, min = Infinity;
  for(const p of window){
    if(p.ft > max) max = p.ft;
    if(p.ft < min) min = p.ft;
  }

  maxEl.textContent = toDisplayFtFromMllw(max).toFixed(2);
  minEl.textContent = toDisplayFtFromMllw(min).toFixed(2);

  metaEl.textContent =
    ``;
}


/* Top ten renderer (MLLW list; converts for display + classification) */
function renderTopTen(){
  topTenBody.innerHTML="";
  TOP_TEN_MLLW.forEach((r,i)=>{
    const navd = mllwToNavd(r.ft);
    const tag = stageTagByNavd(navd);
    const disp = toDisplayFtFromMllw(r.ft);
    const tr=document.createElement("tr");
    tr.innerHTML=`
      <td><b>#${i+1}</b></td>
      <td>${r.date}</td>
      <td><b>${disp.toFixed(2)}</b></td>
      <td><span class="tag"><span class="chip" style="background:${tag.c}"></span>${tag.txt}</span></td>
    `;
    topTenBody.appendChild(tr);
  });
}

/* Helpers for predictions alignment (used later) */
function ceilToNext15MinISO(iso){
  const d = new Date(iso);
  if(Number.isNaN(d.getTime())) return iso;
  const t = d.getTime();
  const step = 15*60*1000;
  const next = Math.ceil((t+1)/step)*step;
  return new Date(next).toISOString();
}

/* =========================
FETCH helper (TXT)
========================= */
async function tryFetchText(url){
  try{
    const res = await fetch(url, { cache:"no-store" });
    if(!res.ok) return {ok:false, url, status:res.status, text:null};
    return {ok:true, url, status:res.status, text: await res.text()};
  }catch(e){
    return {ok:false, url, status:"NETWORK", text:null, err:(e?.message||String(e))};
  }
}

async function resolveDailyTidesTXTUrl(){
  const failures = [];
  for(const candidate of TXT_PATH_CANDIDATES){
    const r = await tryFetchText(candidate);
    if(r.ok){
      DAILY_TIDES_TXT_URL = candidate;
      // suppress TXT OK message in UI
      // setTXTStatus(`TXT OK: loaded ${candidate}`);
      return { url: candidate, text: r.text };
    }else{
      failures.push(`${candidate} (${r.status}${r.err ? `: ${r.err}` : ""})`);
    }
  }
  // still show real errors
  setTXTStatus("TXT ERROR: could not load daily tides file. Tried: " + failures.join(" · "));
  throw new Error("TXT not found. Tried: " + failures.join(" | "));
}

/* =========================
Parse USGS daily tab-delimited TXT
========================= */
let DAILY_TIDES = [];
let DAILY_EVENTS_NAVD = [];

function parseUSGSDailyTidesTXT(text){
  const lines = text.split(/\r?\n/);

  let headerLineIndex = -1;
  for(let i=0;i<lines.length;i++){
    const ln = lines[i];
    if(!ln) continue;
    if(ln.startsWith("#")) continue;
    if(ln.startsWith("agency_cd\t")) { headerLineIndex = i; break; }
  }
  if(headerLineIndex < 0) throw new Error("TXT parse error: could not find header row starting with 'agency_cd'.");

  const header = lines[headerLineIndex].split("\t");
  const idxDate = header.indexOf("datetime");
  const idxHigh = header.indexOf(COL_DAILY_HIGH);
  const idxLowHi = header.indexOf(COL_DAILY_LOWHI);

  if(idxDate < 0 || idxHigh < 0 || idxLowHi < 0){
    const missing = [
      idxDate < 0 ? "datetime" : null,
      idxHigh < 0 ? COL_DAILY_HIGH : null,
      idxLowHi < 0 ? COL_DAILY_LOWHI : null
    ].filter(Boolean).join(" / ");
    setTXTStatus(`TXT ERROR: missing column(s): ${missing}`);
    throw new Error("TXT missing required columns: " + missing);
  }

  const out=[];
  for(let i=headerLineIndex+1;i<lines.length;i++){
    const ln = lines[i];
    if(!ln) continue;
    if(ln.startsWith("#")) continue;

    const parts = ln.split("\t");
    if(parts.length < header.length) continue;

    const dtStr = (parts[idxDate] || "").trim();
    if(!/^\d{4}-\d{2}-\d{2}$/.test(dtStr)) continue;

    const y = +dtStr.slice(0,4);
    const m = +dtStr.slice(5,7);
    const d = +dtStr.slice(8,10);

    const highStr = (parts[idxHigh] || "").trim();
    const lowhiStr = (parts[idxLowHi] || "").trim();

    const highNavd = highStr === "" ? null : +highStr;
    const lowhiNavd = lowhiStr === "" ? null : +lowhiStr;

    if((highNavd!==null && Number.isFinite(highNavd)) || (lowhiNavd!==null && Number.isFinite(lowhiNavd))){
      out.push({y,m,d, highNavd:Number.isFinite(highNavd)?highNavd:null, lowhiNavd:Number.isFinite(lowhiNavd)?lowhiNavd:null});
    }
  }
  out.sort((a,b)=> (a.y-b.y) || (a.m-b.m) || (a.d-b.d));
  return out;
}

function buildDailyEventsFromDailyTides(rows){
  const ev=[];
  for(const r of rows){
    const t = new Date(Date.UTC(r.y, r.m-1, r.d, 17, 0, 0)).toISOString(); // noon EST as 17:00Z
    if(r.highNavd!==null) ev.push({t, ft:r.highNavd, kind:"High", y:r.y, m:r.m, d:r.d});
    if(r.lowhiNavd!==null) ev.push({t, ft:r.lowhiNavd, kind:"Low-High", y:r.y, m:r.m, d:r.d});
  }
  ev.sort((a,b)=>new Date(a.t)-new Date(b.t));
  return ev;
}

async function loadDailyTidesFromTXT(){
  const {url, text} = await resolveDailyTidesTXTUrl();
  DAILY_TIDES = parseUSGSDailyTidesTXT(text);
  DAILY_EVENTS_NAVD = buildDailyEventsFromDailyTides(DAILY_TIDES);
  setTXTStatus(""); // suppress TXT OK message
}
// --- PETSS: try multiple possible output filenames (works on Pages + local) ---
const PETSS_JSON_CANDIDATES = [
  "data/petss_forecast.json",
  "./data/petss_forecast.json",
  "/data/petss_forecast.json",

  // common variants if you name files per-station:
  `data/petss_forecast_${COOPS_STATION}_mllw.json`,
  `./data/petss_forecast_${COOPS_STATION}_mllw.json`,
  `/data/petss_forecast_${COOPS_STATION}_mllw.json`,

  // keep your old guess as a last resort
  "data/petss_forecast_8536889_mllw.json"
];

// returns parsed points in the format your chart expects: [{t, ft}]
function normalizePetssJsonToPoints(json){
  // Option A: { points: [{t, fcst, ...}, ...] }
  if(Array.isArray(json?.points)){
    return json.points
      .map(p => ({ t: p.t, ft: Number(p.fcst ?? p.twl ?? p.value) }))
      .filter(p => p.t && Number.isFinite(p.ft))
      .sort((a,b)=> new Date(a.t) - new Date(b.t));
  }

  // Option B: [{t, fcst}, ...]
  if(Array.isArray(json)){
    return json
      .map(p => ({ t: p.t ?? p.time ?? p.validTime, ft: Number(p.fcst ?? p.twl ?? p.value ?? p.primary) }))
      .filter(p => p.t && Number.isFinite(p.ft))
      .sort((a,b)=> new Date(a.t) - new Date(b.t));
  }

  // Option C: { data: [...] }
  if(Array.isArray(json?.data)){
    return json.data
      .map(p => ({ t: p.t ?? p.time ?? p.validTime, ft: Number(p.fcst ?? p.twl ?? p.value ?? p.primary) }))
      .filter(p => p.t && Number.isFinite(p.ft))
      .sort((a,b)=> new Date(a.t) - new Date(b.t));
  }

  return [];
}

async function fetchFirstOkJson(urls){
  const errs = [];
  for(const u of urls){
    try{
      const res = await fetch(`${u}?v=${Date.now()}`, { cache:"no-store" });
      if(!res.ok) throw new Error(`HTTP ${res.status}`);
      const j = await res.json();
      return { url: u, json: j };
    }catch(e){
      errs.push(`${u} (${e?.message || e})`);
    }
  }
  throw new Error("PETSS JSON not found. Tried: " + errs.join(" | "));
}

async function fetchPETSSForecast_MLLW({ hours = 48 } = {}){
  const { url, json } = await fetchFirstOkJson(PETSS_JSON_CANDIDATES);

  const issuedTime =
    json?.model_time_utc ||
    json?.issued_utc ||
    json?.fetched_utc ||
    json?.issuedTime ||
    null;

  const ptsAll = normalizePetssJsonToPoints(json);

  // IMPORTANT:
  // Do NOT clip to "first timestamp + hours".
  // The chart itself already slices/resamples to the correct window (now → now+72h).
  return { issuedTime, points: ptsAll, urlUsed: url };
}


/* =========================
USGS IV fetch — STRICTLY tidal elevation 72279 (not discharge)
========================= */
async function fetchIV({startISO=null,endISO=null,period=null}={}){
  const url=new URL("https://waterservices.usgs.gov/nwis/iv/");
  url.searchParams.set("format","json");
  url.searchParams.set("sites",USGS_SITE);
  url.searchParams.set("parameterCd",USGS_PARAM_PRIMARY);
  url.searchParams.set("siteStatus","all");
  url.searchParams.set("agencyCd","USGS");
  if(period) url.searchParams.set("period",period);
  if(startISO) url.searchParams.set("startDT",startISO);
  if(endISO) url.searchParams.set("endDT",endISO);

  const res=await fetch(url.toString(),{cache:"no-store"});
  if(!res.ok) throw new Error("USGS IV failed "+res.status);
  return res.json();
}

function extractWaterLevelSeries_NAVD88(json){
  const tss = json?.value?.timeSeries || [];
  const candidates = tss.filter(ts => {
    const code = ts?.variable?.variableCode?.[0]?.value || null;
    if(code !== USGS_PARAM_PRIMARY) return false;
    const unit = (ts?.variable?.unit?.unitCode || "").toLowerCase();
    return (unit === "" || unit.includes("ft"));
  });

  if(!candidates.length){
    const have = tss.map(ts=>ts?.variable?.variableCode?.[0]?.value).filter(Boolean);
    throw new Error(`USGS returned no tidal elevation series for ${USGS_PARAM_PRIMARY}. Returned: ${[...new Set(have)].join(", ")}`);
  }

  let best=[];
  for(const ts of candidates){
    const vals = ts?.values?.[0]?.value || [];
    const pts = vals
      .map(v=>({t:v.dateTime, ft:Number(v.value)}))
      .filter(p=>p.t && Number.isFinite(p.ft));
    if(pts.length > best.length) best = pts;
  }
  return best;
}

async function fetchObservedSeries({startISO=null,endISO=null,period=null}={}){
  const j = await fetchIV({startISO,endISO,period});
  return extractWaterLevelSeries_NAVD88(j);
}

/* =========================
NOAA/NWS NWPS official forecast (BVVN4) -> we resample to 15-min later
Replaces CO-OPS predictions block.
Returns MLLW ft as [{t: ISO8601, ft: Number}] plus issuedTime for UI.
========================= */
const NWPS_GAUGE = "BVVN4";
const NWPS_STAGEFLOW_URL = `https://api.water.noaa.gov/nwps/v1/gauges/${NWPS_GAUGE}/stageflow`;

/* Clip to N hours from the first point (keeps your existing 72h logic consistent). */
function clipHoursFromFirst(points, hours){
  if(!hours || !points?.length) return points || [];
  const t0 = new Date(points[0].t).getTime();
  if(!Number.isFinite(t0)) return points || [];
  const t1 = t0 + hours*3600*1000;
  return points.filter(p => {
    const tt = new Date(p.t).getTime();
    return Number.isFinite(tt) && tt <= t1;
  });
}

/* Best-effort extraction across common NWPS response shapes. */
function extractNWPSForecastSeries(json){
  // Your sample shows top-level json.data[]
  if(Array.isArray(json?.data) && json.data.length) return json.data;

  // Some NWPS responses include nested forecast series
  if(Array.isArray(json?.forecast?.timeSeries) && json.forecast.timeSeries.length){
    const d = json.forecast.timeSeries[0]?.data;
    if(Array.isArray(d) && d.length) return d;
  }
  if(Array.isArray(json?.forecast?.data) && json.forecast.data.length) return json.forecast.data;

  return [];
}

async function fetchNWPSpredictions_MLLW({ hours = 72 } = {}){
  const res = await fetch(NWPS_STAGEFLOW_URL, { cache: "no-store" });
  if(!res.ok) throw new Error("NWPS stageflow failed " + res.status);

  const j = await res.json();

  const issuedTime = j.issuedTime || j.issued_time || null;
  const raw = extractNWPSForecastSeries(j);

  const pts = raw
    .map(d => ({
      t: d.validTime || d.valid_time,
      ft: Number(d.primary)
    }))
    .filter(p => p.t && Number.isFinite(p.ft))
    .sort((a,b)=> new Date(a.t) - new Date(b.t));

  return { issuedTime, points: clipHoursFromFirst(pts, hours) };
}


/* =========================
Alerts
========================= */
async function updateAlerts(){
  try{
    const url = `https://api.weather.gov/alerts/active?point=${ALERT_POINT.lat},${ALERT_POINT.lon}`;
    const res=await fetch(url,{cache:"no-store"});
    if(!res.ok) throw new Error("alerts "+res.status);
    const j=await res.json();
    const feats=j?.features||[];
    const coastal=feats.find(f=>((f?.properties?.event||"").toLowerCase().includes("coastal flood")));
    if(!coastal){ alertBanner.style.display="none"; return; }
    const p=coastal.properties||{};
    alertTitle.textContent=p.event||"Coastal Flood Alert";
    const ends=p.ends?fmtESTFull(p.ends):(p.expires?fmtESTFull(p.expires):"—");
    alertBody.textContent=(p.headline?p.headline+" · ":"")+"Ends: "+ends;
    alertBanner.style.display="block";
  }catch{
    alertBanner.style.display="none";
  }
}

/* =========================
Timeseries quality requirements:
- 15-min grid
- do not connect across gaps (>15 min) -> nulls on grid achieve this
- if jump >0.75 ft across 15 min, drop the later point (null)
========================= */
const TS_STEP_MIN = 15;
const TS_STEP_MS  = TS_STEP_MIN * 60 * 1000;
const TS_MAX_DELTA_FT = 0.75;

function buildFixedGrid15Min_fromAny(series, startISO, endISO){
  const start = new Date(startISO).getTime();
  const end = new Date(endISO).getTime();

  const m = new Map();
  for(const p of (series||[])){
    const t = new Date(p.t).getTime();
    if(Number.isNaN(t) || !Number.isFinite(p.ft)) continue;
    const snapped = Math.round(t/TS_STEP_MS)*TS_STEP_MS;
    m.set(snapped, p.ft);
  }

  const labels=[], values=[];
  const s0 = Math.floor(start/TS_STEP_MS)*TS_STEP_MS;
  const e0 = Math.ceil(end/TS_STEP_MS)*TS_STEP_MS;

  for(let t=s0; t<=e0; t+=TS_STEP_MS){
    labels.push(new Date(t).toISOString());
    values.push(m.has(t) ? m.get(t) : null);
  }
  return {labels, values};
}

function filterSpikes15Min(values, maxDeltaFt=TS_MAX_DELTA_FT){
  const out = values.slice();
  let lastGood = null;
  for(let i=0;i<out.length;i++){
    const v = out[i];
    if(v===null || v===undefined || Number.isNaN(v)) continue;
    if(lastGood===null){
      lastGood = v;
      continue;
    }
    if(Math.abs(v - lastGood) > maxDeltaFt){
      out[i] = null; // do not plot that data
    }else{
      lastGood = v;
    }
  }
  return out;
}

/* Resample predictions to 15-min grid via linear interpolation
   (required for hourly / irregular NWPS forecasts) */
function resampleTo15Min_MLLW(predSeries, startISO, endISO){
  const start = new Date(startISO).getTime();
  const end   = new Date(endISO).getTime();

  const pts = (predSeries || [])
    .map(p => ({
      t: new Date(p.t).getTime(),
      ft: Number(p.ft)
    }))
    .filter(p => Number.isFinite(p.t) && Number.isFinite(p.ft))
    .sort((a,b) => a.t - b.t);

  const labels = [];
  const values = [];

  const s0 = Math.floor(start / TS_STEP_MS) * TS_STEP_MS;
  const e0 = Math.ceil(end   / TS_STEP_MS) * TS_STEP_MS;

  if(!pts.length){
    for(let t = s0; t <= e0; t += TS_STEP_MS){
      labels.push(new Date(t).toISOString());
      values.push(null);
    }
    return { labels, values };
  }

  const MAX_BRACKET_GAP_MS = 3 * 3600 * 1000; // do not interpolate across large gaps
  let i = 0;

  for(let t = s0; t <= e0; t += TS_STEP_MS){
    labels.push(new Date(t).toISOString());

    while(i < pts.length && pts[i].t < t) i++;

    if(i === 0){
      values.push(Math.abs(pts[0].t - t) <= TS_STEP_MS ? pts[0].ft : null);
      continue;
    }

    if(i >= pts.length){
      values.push(
        Math.abs(pts[pts.length - 1].t - t) <= TS_STEP_MS
          ? pts[pts.length - 1].ft
          : null
      );
      continue;
    }

    const p0 = pts[i - 1];
    const p1 = pts[i];
    const gap = p1.t - p0.t;

    if(gap <= 0 || gap > MAX_BRACKET_GAP_MS){
      values.push(null);
      continue;
    }

    if(t < p0.t || t > p1.t){
      values.push(null);
      continue;
    }

    const f = (t - p0.t) / gap;
    values.push(p0.ft + f * (p1.ft - p0.ft));
  }

  return { labels, values };
}

const floodBandsPlugin = {
  id: "floodBands",
  beforeDatasetsDraw(chart) {
    if (chart?.canvas?.id !== "tsChart") return;

    const { ctx, chartArea, scales } = chart;
    if (!ctx || !chartArea || !scales?.y) return;

    const y = scales.y;
    const left = chartArea.left, right = chartArea.right;

    const T = THRESH[DISPLAY_DATUM];
    const yMinor = y.getPixelForValue(T.minorLow);
    const yModer = y.getPixelForValue(T.moderateLow);
    const yMajor = y.getPixelForValue(T.majorLow);

    if (![yMinor, yModer, yMajor].every(Number.isFinite)) return;

    ctx.save();

    // bands
    ctx.fillStyle = "rgba(251,191,36,.10)";
    ctx.fillRect(left, yModer, right-left, (yMinor - yModer));

    ctx.fillStyle = "rgba(251,113,133,.10)";
    ctx.fillRect(left, yMajor, right-left, (yModer - yMajor));

    ctx.fillStyle = "rgba(167,139,250,.10)";
    ctx.fillRect(left, chartArea.top, right-left, (yMajor - chartArea.top));

    // dashed lines
    ctx.setLineDash([6,4]);
    ctx.lineWidth = 1.5;

    const hline = (py, stroke) => {
      ctx.strokeStyle = stroke;
      ctx.beginPath();
      ctx.moveTo(left, py);
      ctx.lineTo(right, py);
      ctx.stroke();
    };

    hline(yMinor, "rgba(251,191,36,.75)");
    hline(yModer, "rgba(251,113,133,.75)");
    hline(yMajor, "rgba(167,139,250,.75)");

    ctx.restore();
  }
};

Chart.register(floodBandsPlugin);


/* =========================
Core state
========================= */
let HIGH_TIDES_NAVD=[];
let annualChart=null, tsChart=null, monthAvgChart=null;
let YEARS=[], annualMinor=[], annualModerate=[], annualMajor=[];

const STATE = { lastNavd:null, ytdNavd:null, todayNavd:null, obs24Navd:null, pred72Mllw:null };

function sliceAfter(series, startISO){
  const s = new Date(startISO).getTime();
  return (series||[]).filter(p=>new Date(p.t).getTime()>=s);
}

function colorForFtDisplay(ftDisplay){
  const T = THRESH[DISPLAY_DATUM];
  if(ftDisplay>=T.majorLow) return "rgba(167,139,250,.95)";
  if(ftDisplay>=T.moderateLow) return "rgba(251,113,133,.95)";
  if(ftDisplay>=T.minorLow) return "rgba(251,191,36,.95)";
  return "rgba(45,212,191,.90)";
}

function extractFloodPeaks_NAVD(series){
  if(!series || series.length < 3) return [];

  const T = THRESH.NAVD88;

  // sort ascending by time + sanitize ft
  const pts = [...series]
    .map(p => ({ t: p.t, ft: Number(p.ft) }))
    .filter(p => p.t && Number.isFinite(p.ft))
    .sort((a,b)=> new Date(a.t) - new Date(b.t));

  if(pts.length < 3) return [];

  // find local maxima (ALL peaks — no minor-threshold gate)
  const candidates = [];
  for(let i=1;i<pts.length-1;i++){
    const a = pts[i-1], b = pts[i], c = pts[i+1];
    if(b.ft >= a.ft && b.ft >= c.ft){
      // avoid flat triple-plateau
      if(!(b.ft === a.ft && b.ft === c.ft)) candidates.push(b);
    }
  }
  if(!candidates.length) return [];

  // de-cluster peaks that are too close together (keep the highest within the window)
  const minSepMs = PEAK_MIN_SEP_MINUTES * 60 * 1000;

  const kept = [];
  let cur = candidates[0];

  for(let i=1;i<candidates.length;i++){
    const p = candidates[i];

    const pt = new Date(p.t).getTime();
    const ct = new Date(cur.t).getTime();

    if(Number.isFinite(pt) && Number.isFinite(ct) && (pt - ct) <= minSepMs){
      if(p.ft > cur.ft) cur = p;
    }else{
      kept.push(cur);
      cur = p;
    }
  }
  kept.push(cur);

  // classify each peak by NAVD thresholds (includes "Below")
  return kept.map(p=>{
    let type = "Below";
    if(p.ft >= T.majorLow) type = "Major";
    else if(p.ft >= T.moderateLow) type = "Moderate";
    else if(p.ft >= T.minorLow) type = "Minor";
    return { t: p.t, ft: p.ft, type };
  });
}

      /* =========================
STEP 3 — build live flood peak events since Jan 1 2026
These are NAVD88 peaks from USGS 15-min data (same datum as your TXT events)
========================= */
async function fetchNOAAHiloHighs({ station, beginYMD, endYMD, datum="MLLW" }){
  const url = new URL("https://api.tidesandcurrents.noaa.gov/api/prod/datagetter");
  url.searchParams.set("product","predictions");
  url.searchParams.set("application", COOPS_APP || "web");
  url.searchParams.set("begin_date", beginYMD); // YYYYMMDD
  url.searchParams.set("end_date", endYMD);     // YYYYMMDD
  url.searchParams.set("datum", datum);
  url.searchParams.set("station", station);
  url.searchParams.set("time_zone","gmt");
  url.searchParams.set("units","english");
  url.searchParams.set("interval","hilo");
  url.searchParams.set("format","json");

  const res = await fetch(url.toString(), { cache:"no-store" });
  if(!res.ok) throw new Error("NOAA hilo predictions failed " + res.status);
  const j = await res.json();

  const preds = j?.predictions || [];
  return preds
    .filter(p => String(p.type || "").toUpperCase() === "H")
    .map(p => ({
      t: new Date(String(p.t).replace(" ", "T") + "Z").toISOString(), // GMT -> ISO
      ft: Number(p.v)
    }))
    .filter(p => p.t && Number.isFinite(p.ft))
    .sort((a,b)=> new Date(a.t) - new Date(b.t));
}

function ymdCompactFromISO(iso){
  const d = new Date(iso);
  const y = d.getUTCFullYear();
  const m = String(d.getUTCMonth()+1).padStart(2,"0");
  const da = String(d.getUTCDate()).padStart(2,"0");
  return `${y}${m}${da}`;
}

async function buildLiveFloodPeaksSince2026(){
  const startISO = LIVE_START_ISO;
  const endISO   = nowISO();

  // observed NAVD88 (15-min)
  const obs = await fetchObservedSeries({ startISO, endISO });
  if(!obs || !obs.length) return [];

  const obsPts = obs
    .map(p => ({ tMs: new Date(p.t).getTime(), ft: Number(p.ft), t: p.t }))
    .filter(p => Number.isFinite(p.tMs) && Number.isFinite(p.ft))
    .sort((a,b)=>a.tMs-b.tMs);

  // predicted HIGH tide times (NOAA hilo)
  const highs = await fetchNOAAHiloHighs({
    station: NOAA_STATION_TIDECLOCK,
    beginYMD: ymdCompactFromISO(startISO),
    endYMD: ymdCompactFromISO(endISO),
    datum: "MLLW"
  });

  const winMs = CREST_WINDOW_HOURS * 3600 * 1000;    // ±2h search window
  const reqMs = REQUIRE_WITHIN_HOURS * 3600 * 1000;  // must have obs within ±1h

  function bestObsNear(centerMs){
    const lo = centerMs - winMs;
    const hi = centerMs + winMs;

    let best = null;
    let haveReq = false;

    for(const p of obsPts){
      if(p.tMs < lo) continue;
      if(p.tMs > hi) break;

      if(Math.abs(p.tMs - centerMs) <= reqMs) haveReq = true;
      if(best === null || p.ft > best.ft) best = p;
    }

    if(!best || !haveReq) return null;
    return best;
  }

  const out = [];
  for(const h of highs){
    const cMs = new Date(h.t).getTime();
    if(!Number.isFinite(cMs)) continue;

    const best = bestObsNear(cMs);
    if(!best) continue;

    out.push({
      t: best.t,          // observed timestamp
      ft: best.ft,        // NAVD88
      kind: "LiveHigh",   // label only
      source: "USGS+NOAA",
      type: classifyByNavd(best.ft).short  // optional
    });
  }

  // de-dupe
  const seen = new Set();
  return out.filter(e=>{
    const k = `${e.t}|${Number(e.ft).toFixed(3)}`;
    if(seen.has(k)) return false;
    seen.add(k);
    return true;
  });
}



/* Peak counting uses NAVD thresholds */
function countFloodPeaks_NAVD(series){
  if(!series || series.length<3) return {minor:0, moderate:0, major:0};
  const T = THRESH.NAVD88;

  const pts = [...series].sort((a,b)=>new Date(a.t)-new Date(b.t));
  const candidates=[];

  for(let i=1;i<pts.length-1;i++){
    const a=pts[i-1], b=pts[i], c=pts[i+1];
    if(b.ft>=T.minorLow && b.ft>=a.ft && b.ft>=c.ft){
      if(!(b.ft===a.ft && b.ft===c.ft)) candidates.push(b);
    }
  }
  if(!candidates.length) return {minor:0, moderate:0, major:0};

  const minSepMs = PEAK_MIN_SEP_MINUTES*60*1000;
  const kept=[];
  let cur = candidates[0];
  for(let i=1;i<candidates.length;i++){
    const p=candidates[i];
    if(new Date(p.t)-new Date(cur.t) <= minSepMs){
      if(p.ft>cur.ft) cur=p;
    }else{
      kept.push(cur);
      cur=p;
    }
  }
  kept.push(cur);

  let minor=0, moderate=0, major=0;
  for(const p of kept){
    if(p.ft>=T.majorLow) major++;
    else if(p.ft>=T.moderateLow) moderate++;
    else minor++;
  }
  return {minor, moderate, major};
}

/* Annual counts from TXT */
function countAnnualFloodsFromTXT(eventsNavd){
  const T = THRESH.NAVD88;
  const byYear = new Map();
  for(const e of eventsNavd){
    const y = e.y || (new Date(e.t)).getUTCFullYear();
    if(!byYear.has(y)) byYear.set(y,{minor:0, moderate:0, major:0});
    if(e.ft >= T.minorLow){
      const rec = byYear.get(y);
      if(e.ft >= T.majorLow) rec.major++;
      else if(e.ft >= T.moderateLow) rec.moderate++;
      else rec.minor++;
    }
  }
  return byYear;
}

function buildAnnualArraysFromHistory_completedYears(){
  const T = THRESH.NAVD88;

  const yearCounts = new Map(); // y -> {minor, moderate, major}

  for(const e of HIGH_TIDES_NAVD){
    const tMs = new Date(e.t).getTime();
    if(!Number.isFinite(tMs)) continue;

    const y = new Date(e.t).getUTCFullYear();
    const ft = +e.ft;
    if(!Number.isFinite(ft)) continue;

    if(!yearCounts.has(y)) yearCounts.set(y,{minor:0, moderate:0, major:0});

    if(ft >= T.majorLow) yearCounts.get(y).major++;
    else if(ft >= T.moderateLow) yearCounts.get(y).moderate++;
    else if(ft >= T.minorLow) yearCounts.get(y).minor++;
  }

  const yearsAll = Array.from(yearCounts.keys()).sort((a,b)=>a-b);
  const curYear = new Date().getFullYear();
  const yearsCompleted = yearsAll.filter(y => y < curYear);

  YEARS = yearsCompleted;
  annualMinor = yearsCompleted.map(y => yearCounts.get(y)?.minor ?? 0);
  annualModerate = yearsCompleted.map(y => yearCounts.get(y)?.moderate ?? 0);
  annualMajor = yearsCompleted.map(y => yearCounts.get(y)?.major ?? 0);
}



function overwriteCurrentYearBarWithLiveCounts(liveCounts){
  if(!liveCounts) return;
  const { y: curYear } = getESTParts(new Date());

  let idx = YEARS.indexOf(curYear);
  if(idx < 0){
    // If the annual arrays were built as "completed years only", append current year.
    YEARS.push(curYear);
    annualMinor.push(0);
    annualModerate.push(0);
    annualMajor.push(0);
    idx = YEARS.length - 1;

    // Keep labels sorted if you want strict order:
    // (If you sort, you must reorder the arrays too; simplest is to not sort here.)
  }

  annualMinor[idx] = liveCounts.minor;
  annualModerate[idx] = liveCounts.moderate;
  annualMajor[idx] = liveCounts.major;
}


/* Annual chart */
function ensureAnnual(){
  if(annualChart) return;
  annualChart=new Chart($("annualChart"),{
    type:"bar",
    data:{
      labels:YEARS,
      datasets:[
        {label:"Minor",data:annualMinor,stack:"f",borderWidth:0,backgroundColor:"rgba(251,191,36,.85)"},
        {label:"Moderate",data:annualModerate,stack:"f",borderWidth:0,backgroundColor:"rgba(251,113,133,.80)"},
        {label:"Major",data:annualMajor,stack:"f",borderWidth:0,backgroundColor:"rgba(167,139,250,.80)"}
      ]
    },
    options:{
      responsive:true,
      maintainAspectRatio:false,
      plugins:{
        legend:{
          position:"bottom",
          labels:{color:"rgba(234,240,255,.88)",font:{weight:"950"},boxWidth:16}
        }
      },
      scales:{
        x:{
          stacked:true,
          ticks:{color:"rgba(169,182,211,.9)",maxRotation:0,autoSkip:true,maxTicksLimit:7},
          grid:{color:"rgba(255,255,255,.06)"}
        },
        y:{
          stacked:true,
          ticks:{color:"rgba(169,182,211,.9)",precision:0},
          grid:{color:"rgba(255,255,255,.06)"}
        }
      }
    }
  });
}

function renderAnnual(){
  ensureAnnual();
  annualChart.data.labels = YEARS;
  annualChart.data.datasets[0].data = annualMinor;
  annualChart.data.datasets[1].data = annualModerate;
  annualChart.data.datasets[2].data = annualMajor;
  annualChart.update();
}

/* Timeseries tick labels (daily) */
function buildDailyTickCallbackSkipFirstDay(labels){
  const seenDays = new Set();
  let firstDay = null;
  return (value, index)=>{
    const iso = labels[index];
    if(!iso) return "";
    const dayStr = fmtESTDay(iso);
    if(firstDay === null) firstDay = dayStr;
    if(seenDays.has(dayStr)) return "";
    seenDays.add(dayStr);
    if(dayStr === firstDay) return "";
    return dayStr;
  };
}

/* Timeseries chart (Observed + Predicted), with NO LINE across null gaps */
function ensureTsChart(){
  if(tsChart) return;

  tsChart = new Chart($("tsChart"),{
    type:"line",
    data:{
      labels:[],
      datasets:[
        {
          label:"Observed (USGS water level)",
          data:[],
          borderWidth:2,
          pointRadius:0,
          pointHoverRadius:0,
          pointHitRadius:0,
          tension:0.25,
          spanGaps:false, // do NOT connect across missing obs
          borderColor:"rgba(45,212,191,.9)",
          segment:{
            borderColor:(ctx)=>{
              const y = ctx?.p1?.parsed?.y;
              if(y===null || y===undefined || Number.isNaN(y)) return "rgba(45,212,191,.9)";
              return colorForFtDisplay(+y);
            }
          }
        },
        {
          label:"Predicted (NOAA)",
          data:[],
          borderWidth:2,
          pointRadius:0,
          pointHoverRadius:0,
          pointHitRadius:0,
          tension:0.25,

          // ✅ IMPORTANT:
          // If you keep hourly-only predictions with nulls between, this MUST be true
          // or the line will be invisible (no dots + no segments).
          // If you later resample predictions to 15-min, you can set this back to false.
          spanGaps:true,

          borderDash:[6,5],
          borderColor:"rgba(45,212,191,.9)",
          segment:{
            borderColor:(ctx)=>{
              const y = ctx?.p1?.parsed?.y;
              if(y===null || y===undefined || Number.isNaN(y)) return "rgba(45,212,191,.9)";
              return colorForFtDisplay(+y);
            }
          }
        }
      ]
    },
    options:{
      responsive:true,
      maintainAspectRatio:false,
      interaction:{ mode:"index", intersect:false },

      plugins:{
        legend:{
          labels:{
            color:"rgba(234,240,255,.88)",
            font:{ weight:"950" }
          }
        },
        tooltip:{
          callbacks:{
            title:(items)=>{
              const idx = items?.[0]?.dataIndex;
              if(idx == null) return "";
              const iso = tsChart?.data?.labels?.[idx];
              return iso ? fmtESTFull(iso) : "";
            },
            label:(ctx)=>{
              const v = ctx.parsed?.y;
              if(!Number.isFinite(v)) return null;
              return `${ctx.dataset.label}: ${v.toFixed(2)} ${unitText()}`;
            }
          }
        }
      },

      scales:{
        x:{
          ticks:{
            color:"rgba(169,182,211,.9)",
            autoSkip:false,
            maxRotation:0,
            callback:()=>"" // overwritten in updateTsChartFromState()
          },
          grid:{ color:"rgba(255,255,255,.06)" }
        },
        y:{
          ticks:{
            color:"rgba(169,182,211,.9)",
            font:{ size:14, weight:"850" }
          },
          grid:{ color:"rgba(255,255,255,.06)" },
          title:{
            display:true,
            text: unitText(),
            color:"rgba(169,182,211,.9)",
            font:{ size:18, weight:"950" }
          }
        }
      }
    }
  });
}



/* Build 15-min obs grid + plot RAW PETSS predictions (no interpolation) */
function isTopOfHourISO(iso){
  const d = new Date(iso);
  return d.getUTCMinutes() === 0 && d.getUTCSeconds() === 0;
}

// Build 15-min labels only (no values)
function build15MinLabels(startISO, endISO){
  const start = new Date(startISO).getTime();
  const end   = new Date(endISO).getTime();

  const s0 = Math.floor(start/TS_STEP_MS)*TS_STEP_MS;
  const e0 = Math.ceil(end/TS_STEP_MS)*TS_STEP_MS;

  const labels = [];
  for(let t = s0; t <= e0; t += TS_STEP_MS){
    labels.push(new Date(t).toISOString());
  }
  return labels;
}

function updateTsChartFromState(){
  const endISO = nowISO();
  const startObsISO = new Date(new Date(endISO).getTime() - 24*3600*1000).toISOString();

  // last obs timestamp (or now)
  const lastObsT = (STATE.obs24Navd && STATE.obs24Navd.length)
    ? STATE.obs24Navd[STATE.obs24Navd.length - 1].t
    : endISO;

  // ✅ predictions start at NEXT hour
  const lastObsMs = new Date(lastObsT).getTime();
  const predStartMs = floorToHourMs(lastObsMs) + HOUR_MS;
  const predStartISO = new Date(predStartMs).toISOString();
  const predEndISO   = new Date(predStartMs + 72*3600*1000).toISOString();
  const predEndMs    = new Date(predEndISO).getTime();

  // ✅ 15-min axis from obs start → forecast end
  const labels = build15MinLabels(startObsISO, predEndISO);

  // -------------------------
  // Observed (NAVD88) -> 15-min grid -> display
  // -------------------------
  const obsGrid = buildFixedGrid15Min_fromAny(STATE.obs24Navd || [], startObsISO, endISO);
  // obsGrid.labels covers only obs window; we need values over the full label axis
  // So: map obs points onto the full labels using the same snap logic

  const obsMap = new Map();
  for(const p of (STATE.obs24Navd || [])){
    const t = new Date(p.t).getTime();
    const ft = Number(p.ft);
    if(!Number.isFinite(t) || !Number.isFinite(ft)) continue;
    const snapped = Math.round(t/TS_STEP_MS)*TS_STEP_MS;
    obsMap.set(snapped, ft);
  }

  const obsValsDisplay = labels.map(iso=>{
    const t = new Date(iso).getTime();
    const v = obsMap.has(t) ? obsMap.get(t) : null;
    return (v==null) ? null : toDisplayFtFromNavd(v);
  });

  // (optional) keep your spike filter for OBS only (15-min makes sense)
  const obsFiltered = filterSpikes15Min(
    obsValsDisplay.map(v => (Number.isFinite(v) ? v : null)),
    TS_MAX_DELTA_FT
  );

// -------------------------
// Predicted (MLLW) -> resample to 15-min -> display
// -------------------------
const predRaw = (STATE.pred72Mllw || [])
  .map(p => ({ t:p.t, ft:Number(p.ft) }))
  .filter(p=>{
    const tMs = new Date(p.t).getTime();
    return p.t && Number.isFinite(p.ft) && Number.isFinite(tMs)
      && tMs >= predStartMs
      && tMs <= predEndMs;
  });

// Resample to 15-min grid (fills in-between so the line can draw)
const predRes = resampleTo15Min_MLLW(predRaw, predStartISO, predEndISO);

// Put resampled predictions onto the FULL axis labels
const predMap = new Map(); // ms -> ft (MLLW)
for(let i=0;i<predRes.labels.length;i++){
  const ms = new Date(predRes.labels[i]).getTime();
  const ft = predRes.values[i];
  if(Number.isFinite(ms) && Number.isFinite(ft)) predMap.set(ms, ft);
}

const predValsDisplay = labels.map(iso=>{
  const t = new Date(iso).getTime();
  if(t < predStartMs || t > predEndMs) return null;
  const mllw = predMap.get(t);
  return Number.isFinite(mllw) ? toDisplayFtFromMllw(mllw) : null;
});


  // -------------------------
  // Plot
  // -------------------------
  ensureTsChart();
  tsChart.data.labels = labels;
  tsChart.data.datasets[0].data = obsFiltered;     // observed 15-min
  tsChart.data.datasets[1].data = predValsDisplay; // predicted hourly-only

  tsChart.options.scales.x.ticks.callback = buildDailyTickCallbackSkipFirstDay(labels);
  tsChart.options.scales.y.title.text = unitText();

  // y-scale includes thresholds
  const {minor, moderate, major} = thresholdsDisplay();
  const ys = [...obsFiltered, ...predValsDisplay].filter(v => Number.isFinite(v));
  ys.push(minor, moderate, major);

  let yMin = Math.min(...ys);
  let yMax = Math.max(...ys);
  const pad = Math.max(0.25, (yMax - yMin) * 0.08);
  yMin -= pad; yMax += pad;

  const STEP = 1.0;
  yMin = Math.floor(yMin / STEP) * STEP;
  yMax = Math.ceil(yMax / STEP) * STEP;

  tsChart.options.scales.y.min = yMin;
  tsChart.options.scales.y.max = yMax;
  tsChart.options.scales.y.ticks.stepSize = STEP;

  tsChart.update();

  // keep your debug line, but don’t keep appending forever:
  if(fcNote){
    const nObs  = obsFiltered.filter(v=>Number.isFinite(v)).length;
    const nPred = predValsDisplay.filter(v=>Number.isFinite(v)).length;
    fcNote.textContent =
      (fcNote.textContent || "").split(" · Plot pts:")[0] +
      ` · Plot pts: obs=${nObs}, pred=${nPred} · Window: ${fmtESTFull(startObsISO)} → ${fmtESTFull(predEndISO)}`;
  }
}



/* =========================
DOY cumulative flooding (NO TXT) — REDONE (clean + datum-safe)
- Pull USGS Daily Values (DV) for your site/param in NAVD88:
    00021 = Daily Maximum (high)
    00022 = Daily (Low-High) / secondary daily stat (depends on USGS series)
- Count “events” >= flood stage:
    flood stage = THRESH[DISPLAY_DATUM].minorLow (auto-updates when datum toggles)
- Build per-year cumulative counts on a 365-day calendar axis (skip Feb 29)
- Plot average + min/max band
========================= */

const DOY_START_ISO = "2000-01-01"; // backfill start (YYYY-MM-DD)
let DOY_CACHE = null;               // { years, avg, min, max, stageLabel }
let doyCumChart = null;

/* Uses your dashboard’s Minor threshold automatically (datum-aware) */
function doyFloodStageDisplayFt(){
  return THRESH?.[DISPLAY_DATUM]?.minorLow ?? 0;
}
function doyStageLabel(){
  const v = doyFloodStageDisplayFt();
  return `Flood stage ≥ ${v.toFixed(2)} ft (${DISPLAY_DATUM})`;
}

/* -------------------------
USGS DV fetch (NAVD88)
------------------------- */
async function fetchUSGSDV({ start="2000-01-01", end=null } = {}){
  const endISO = end || new Date().toISOString().slice(0,10);

  const url = new URL("https://waterservices.usgs.gov/nwis/dv/");
  url.searchParams.set("format","json");
  url.searchParams.set("sites", USGS_SITE);
  url.searchParams.set("parameterCd", USGS_PARAM_PRIMARY);     // e.g., 72279
  url.searchParams.set("startDT", start);
  url.searchParams.set("endDT", endISO);
  url.searchParams.set("statisticCd", "00021,00022");
  url.searchParams.set("siteStatus","all");

  const res = await fetch(url.toString(), { cache:"no-store" });
  if(!res.ok) throw new Error("USGS DV failed " + res.status);
  return res.json();
}

/* Identify a DV series’ statistic code reliably if possible */
function getStatCode(ts){
  const opt = ts?.variable?.options?.option || [];
  const hit = opt.find(o => String(o?.name||"").toLowerCase() === "statistic code");
  return hit ? String(hit.value) : null;
}

/* Extract DV points (date -> value), date is YYYY-MM-DD */
function extractDVPoints(ts){
  const vals = ts?.values?.[0]?.value || [];
  return vals
    .map(v => ({
      date: String(v?.dateTime || "").slice(0,10),
      ft: Number(v?.value)
    }))
    .filter(p => /^\d{4}-\d{2}-\d{2}$/.test(p.date) && Number.isFinite(p.ft));
}

/* Fetch + normalize into rows:
   [{y,m,d,date, highNavd, lowhiNavd}]  (NAVD88) */
async function fetchUSGSDailyStats_NAVD88({ start=DOY_START_ISO, end=null } = {}){
  const j = await fetchUSGSDV({ start, end });
  const tss = j?.value?.timeSeries || [];
  if(!tss.length) throw new Error("USGS DV returned no timeSeries.");

  // Bucket series by statistic code
  let tsHigh = null, tsLowHi = null;

  for(const ts of tss){
    const sc = getStatCode(ts);
    if(sc === "00021") tsHigh = ts;
    else if(sc === "00022") tsLowHi = ts;
  }

  // Fallback: if statCode metadata isn’t present, pick two largest series.
  if(!tsHigh || !tsLowHi){
    const sorted = [...tss].sort((a,b)=>(b?.values?.[0]?.value?.length||0)-(a?.values?.[0]?.value?.length||0));
    if(!tsHigh)  tsHigh  = sorted[0] || null;
    if(!tsLowHi) tsLowHi = sorted[1] || null;
  }
  if(!tsHigh)  throw new Error("USGS DV: could not identify daily HIGH (00021) series.");
  if(!tsLowHi) throw new Error("USGS DV: could not identify daily LOW-HIGH (00022) series.");

  const highPts  = extractDVPoints(tsHigh);
  const lowhiPts = extractDVPoints(tsLowHi);

  const map = new Map(); // date -> {highNavd, lowhiNavd}
  for(const p of highPts){
    if(!map.has(p.date)) map.set(p.date, { highNavd:null, lowhiNavd:null });
    map.get(p.date).highNavd = p.ft;
  }
  for(const p of lowhiPts){
    if(!map.has(p.date)) map.set(p.date, { highNavd:null, lowhiNavd:null });
    map.get(p.date).lowhiNavd = p.ft;
  }

  const rows = [];
  for(const [date, v] of map.entries()){
    const y = +date.slice(0,4);
    const m = +date.slice(5,7);
    const d = +date.slice(8,10);
    rows.push({ y, m, d, date, highNavd:v.highNavd, lowhiNavd:v.lowhiNavd });
  }
  rows.sort((a,b)=> a.date.localeCompare(b.date));
  return rows;
}

/* -------------------------
Calendar index (365-day axis)
------------------------- */
function isLeapYear(y){
  return (y % 4 === 0 && y % 100 !== 0) || (y % 400 === 0);
}
// returns 0..364, or null for Feb 29
function calIndex365(y,m,d){
  if(m === 2 && d === 29) return null;
  const dt   = new Date(Date.UTC(y, m-1, d, 12,0,0));
  const jan1 = new Date(Date.UTC(y, 0,   1, 12,0,0));
  let idx = Math.floor((dt - jan1)/86400000); // 0-based day of year
  if(isLeapYear(y) && m > 2) idx -= 1;        // compress after Feb 29
  return idx;                                  // 0..364
}
function monthStarts365(){
  const y = 2021; // non-leap
  const out = [];
  for(let m=1;m<=12;m++) out.push(calIndex365(y,m,1));
  return out;
}

/* -------------------------
Compute stats
- counts “events” separately: daily high + daily low-high if each meets stage
------------------------- */
function computeDOYStatsFromDailyRows(rows){
  const stageDisplay = doyFloodStageDisplayFt();

  function meetsStage(navdFt){
    const disp = toDisplayFtFromNavd(navdFt);
    return Number.isFinite(disp) && disp >= stageDisplay;
  }

  const byYear = new Map(); // y -> dailyCounts[365]

  for(const r of rows){
    const idx = calIndex365(r.y, r.m, r.d);
    if(idx === null) continue;

    let add = 0;
    if(Number.isFinite(r.highNavd)  && meetsStage(r.highNavd))  add += 1;
    if(Number.isFinite(r.lowhiNavd) && meetsStage(r.lowhiNavd)) add += 1;
    if(add === 0) continue;

    if(!byYear.has(r.y)) byYear.set(r.y, new Array(365).fill(0));
    byYear.get(r.y)[idx] += add;
  }

  const years = Array.from(byYear.keys()).sort((a,b)=>a-b);
  if(!years.length) return null;

  // cumulative per year
  const cumByYear = years.map(y=>{
    const daily = byYear.get(y);
    const cum = new Array(365).fill(0);
    let run = 0;
    for(let i=0;i<365;i++){
      run += (daily[i] || 0);
      cum[i] = run;
    }
    return { y, cum };
  });

  const avg = new Array(365).fill(0);
  const min = new Array(365).fill(0);
  const max = new Array(365).fill(0);

  for(let i=0;i<365;i++){
    let lo = Infinity, hi = -Infinity, sum = 0;
    for(const yr of cumByYear){
      const v = yr.cum[i];
      if(v < lo) lo = v;
      if(v > hi) hi = v;
      sum += v;
    }
    avg[i] = sum / cumByYear.length;
    min[i] = lo;
    max[i] = hi;
  }

  return { years, avg, min, max, stageLabel: doyStageLabel() };
}

      function doyIndexToMonthDay(idx){
  // idx = 0..364 on non-leap calendar
  const base = new Date(Date.UTC(2021, 0, 1)); // non-leap year
  const d = new Date(base.getTime() + idx * 86400000);

  const m = d.toLocaleString("en-US", { month:"short", timeZone:"UTC" });
  const day = d.getUTCDate();
  return `${m} ${day}`;
}

      function buildYTDSeriesFromDailyRows(){
  // Uses the same logic as DOY (daily stats rows -> counts -> cumulative),
  // but only for the current year and stops at "today".

  if(!DOY_ROWS_CACHE || !DOY_ROWS_CACHE.length) return null;

const { y: yNow, m: mNow, d: dNow } = getESTParts(new Date());


  const todayIdx = calIndex365(yNow, mNow, dNow);
  if(todayIdx === null) return null;

  const stageDisplay = THRESH?.[DISPLAY_DATUM]?.minorLow ?? 0;

  function meetsStage(navdFt){
    const disp = toDisplayFtFromNavd(navdFt);
    return Number.isFinite(disp) && disp >= stageDisplay;
  }

  // daily counts for current year
  const daily = new Array(365).fill(0);

  for(const r of DOY_ROWS_CACHE){
    if(r.y !== yNow) continue;
    const idx = calIndex365(r.y, r.m, r.d);
    if(idx === null) continue;

    let add = 0;
    if(Number.isFinite(r.highNavd)  && meetsStage(r.highNavd))  add += 1;
    if(Number.isFinite(r.lowhiNavd) && meetsStage(r.lowhiNavd)) add += 1;

    if(add) daily[idx] += add;
  }

  // cumulative, and null after today so it doesn’t draw “future flatline”
  const ytd = new Array(365).fill(null);
  let run = 0;
  for(let i=0;i<365;i++){
    run += daily[i];
    ytd[i] = (i <= todayIdx) ? run : null;
  }

  return ytd;
}


/* -------------------------
Render chart
------------------------- */
function renderDOYCumPanel(){
  const meta   = document.getElementById("doyMeta");
  const note   = document.getElementById("doyNote");
  const canvas = document.getElementById("doyCumChart");
  if(!canvas) return;

  if(!DOY_CACHE){
    if(meta) meta.textContent = "Loading daily stats…";
    if(note) note.textContent = "";
    return;
  }

  const { years, avg, min, max, stageLabel } = DOY_CACHE;

  const { y: CUR_Y } = getESTParts(new Date());
  const ytd = buildYTDSeriesFromDailyRows();

  if(meta){
    meta.textContent = `${years[0]}–${years[years.length-1]} · ${stageLabel}`;
  }
  if(note){
    note.textContent = "";
  }

  const labels  = Array.from({length:365}, (_,i)=> i+1);
  const mStarts = monthStarts365();
  const mNames  = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];

 const data = {
  labels,
  datasets: [
    // helper for band fill (NOT shown in legend)
    {
      label: "_rangeMin",
      data: min,
      borderWidth: 0,
      pointRadius: 0,
      pointHoverRadius: 0, // ✅ Step 1B
      pointHitRadius: 0,   // ✅ Step 1B
      showLine: false
    },

    {
      label: "Historic Range (min–max)",
      data: max,
      borderWidth: 0,
      pointRadius: 0,
      pointHoverRadius: 0, // ✅ Step 1B
      pointHitRadius: 0,   // ✅ Step 1B
      fill: "-1",
      backgroundColor: "rgba(255,255,255,0.18)"
    },
{
  label: "Average",
  data: avg,
  borderWidth: 2,
  tension: 0.25,

  // line styling
  borderColor: "rgba(45,212,191,.95)",
  backgroundColor: "rgba(45,212,191,.95)", // ✅ REQUIRED for filled legend

  // kill all points (including hover dots)
  pointRadius: 0,
  pointHoverRadius: 0,
  pointHitRadius: 0,

  // ✅ force legend chip to be a solid filled square
  pointStyle: "rectFilled",
  pointBackgroundColor: "rgba(45,212,191,.95)",
  pointBorderColor: "rgba(45,212,191,.95)",
  pointBorderWidth: 0,

  fill: false
},


    // ✅ YTD line labeled as the actual current year (2026, 2027, ...)
    {
      label: String(CUR_Y),
      data: ytd || new Array(365).fill(null),
      borderWidth: 3,
      pointRadius: 0,
      pointHoverRadius: 0,
      pointHitRadius: 0,
      tension: 0.25,
      borderColor: "#ef4444",
      backgroundColor: "#ef4444",
      spanGaps: false,

      // ✅ Legend chip becomes a filled square (matches Average)
      pointStyle: "rectFilled",
      pointBackgroundColor: "#ef4444",
      pointBorderColor: "#ef4444"
    }
  ]
};

const options = {
  responsive:true,
  maintainAspectRatio:false,
  interaction:{mode:"index", intersect:false},

  // ✅ Step 1A: remove the hover “dot” entirely (global)
  elements:{
    point:{
      radius:0,
      hoverRadius:0,
      hitRadius:0
    }
  },

  plugins:{
    legend: { // ✅ spelled correctly
      position:"bottom",
      labels:{
        color:"rgba(234,240,255,.88)",
        font:{weight:"950"},
        boxWidth:14,

        // ✅ Use filled point-style legend markers
        usePointStyle:true,

        filter:(legendItem, data)=>{
          const label = data?.datasets?.[legendItem.datasetIndex]?.label || "";
          return label !== "_rangeMin"; // ✅ hide helper from legend
        }
      }
    },
    tooltip:{
      callbacks:{
        title:(items)=>{
          const idx = items?.[0]?.dataIndex;
          if(idx == null) return "";
          return doyIndexToMonthDay(idx);
        },
        label:(ctx)=>{
          const v = ctx.parsed?.y;
          if(!Number.isFinite(v)) return null;

          // Only show tooltip for Average + current year
          const want = new Set(["Average", String(CUR_Y)]);
          if(!want.has(ctx.dataset.label)) return null;

          return `${ctx.dataset.label}: ${Math.round(v*100)/100}`;
        }
      }
    }
  },

  scales:{
    x:{
      ticks:{
        color:"rgba(169,182,211,.9)",
        autoSkip:false,
        maxRotation:0,
        callback:(value, index)=>{
          const m = mStarts.indexOf(index);
          return (m >= 0) ? mNames[m] : "";
        }
      },
      grid:{display:false}
    },
    y:{
      ticks:{color:"rgba(169,182,211,.9)"},
      grid:{color:"rgba(255,255,255,.06)"}
    }
  }
};

if(doyCumChart) doyCumChart.destroy();
doyCumChart = new Chart(canvas.getContext("2d"), { type:"line", data, options });
}

/* -------------------------
Init (one-time load)
Call this once in boot(), NOT every 5 minutes.
------------------------- */
async function initDOYCumulativeFromAPI(){
  DOY_CACHE = null;
  renderDOYCumPanel(); // show "Loading..."

  const rows = await fetchUSGSDailyStats_NAVD88({ start: DOY_START_ISO });
  DOY_CACHE = computeDOYStatsFromDailyRows(rows);
  renderDOYCumPanel();
}

/* -------------------------
Datum toggle hook
When DISPLAY_DATUM flips, recompute from cached rows? (fast path)
Simplest: recompute from already-fetched rows by storing rows too.
If you want that, add DOY_ROWS_CACHE below.
------------------------- */

// OPTIONAL FAST PATH (recommended):
let DOY_ROWS_CACHE = null;

async function initDOYCumulativeFromAPI_FAST(){
  DOY_CACHE = null;
  renderDOYCumPanel();

  DOY_ROWS_CACHE = await fetchUSGSDailyStats_NAVD88({ start: DOY_START_ISO });
  DOY_CACHE = computeDOYStatsFromDailyRows(DOY_ROWS_CACHE);
  renderDOYCumPanel();
}

function refreshDOYAfterDatumToggle(){
  if(!DOY_ROWS_CACHE) { renderDOYCumPanel(); return; }
  DOY_CACHE = computeDOYStatsFromDailyRows(DOY_ROWS_CACHE);
  renderDOYCumPanel();
}

/* =========================
Historic filter from TXT
========================= */
async function hydrateHistoricFromTXT(){
  // 1) Base history from TXT (NAVD88 daily “events”)
  const txtEvents = (DAILY_EVENTS_NAVD||[]).map(e=>({
    t:e.t, ft:e.ft, kind:e.kind, y:e.y, m:e.m, d:e.d,
    source:"TXT"
  }));

  // 2) Live peaks from USGS since Jan 1 2026 (NAVD88)
  let livePeaks = [];
  try{
    livePeaks = await buildLiveFloodPeaksSince2026();
  }catch(e){
    console.error("Live peaks build failed:", e);
    livePeaks = [];
  }

  // 3) Combine
  const combined = [...txtEvents, ...livePeaks];

  // 4) De-duplicate by timestamp+height (prevents duplicates if anything overlaps)
  const seen = new Set();
  HIGH_TIDES_NAVD = combined.filter(r=>{
    const key = `${r.t}|${Number(r.ft).toFixed(3)}`;
    if(seen.has(key)) return false;
    seen.add(key);
    return true;
  });

  // 5) Newest first for “recent”
  HIGH_TIDES_NAVD.sort((a,b)=>new Date(b.t)-new Date(a.t));

  // 6) Refresh UI pieces that depend on HIGH_TIDES_NAVD
  applyFilter();
  if(histMeta) histMeta.textContent = "";
}


function renderHist(rowsNavd){
  histBody.innerHTML = "";

  const LIMIT = 10;                      // ✅ only show 10
  const show = rowsNavd.slice(0, LIMIT);

  for(const r of show){
    const tag  = stageTagByNavd(r.ft);
    const disp = toDisplayFtFromNavd(r.ft);

    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${fmtNiceDate(r.t)}</td>
      <td><b>${disp.toFixed(2)}</b></td>
      <td><span class="tag"><span class="chip" style="background:${tag.c}"></span>${tag.txt}</span></td>
    `;
    histBody.appendChild(tr);
  }

  histMeta.textContent = `Showing ${Math.min(LIMIT, rowsNavd.length)} of ${rowsNavd.length.toLocaleString()}`;
}

function applyFilter(){
  // NEW: range inputs (display datum)
  const minDisplay = parseFloat(minElevEl.value);
  const maxDisplay = parseFloat(maxElevEl.value);

  // NEW: date inputs (YYYY-MM-DD) — inclusive
  const fromStr = (fromDateEl?.value || "").trim();
  const toStr   = (toDateEl?.value   || "").trim();

  // Convert elev range -> NAVD (your data are NAVD)
  const minNavd = Number.isFinite(minDisplay) ? fromDisplayToNavd(minDisplay) : -Infinity;
  const maxNavd = Number.isFinite(maxDisplay) ? fromDisplayToNavd(maxDisplay) :  Infinity;

  // Build date bounds in ms (inclusive). Using UTC parsing is fine since we compare ISO times.
  const fromMs = fromStr ? new Date(fromStr + "T00:00:00Z").getTime() : -Infinity;
  const toMs   = toStr   ? new Date(toStr   + "T23:59:59Z").getTime() :  Infinity;

  const mode = sortModeEl.value;

  let rows = HIGH_TIDES_NAVD.filter(r=>{
    if(r.ft < minNavd || r.ft > maxNavd) return false;

    const tMs = new Date(r.t).getTime();
    if(!Number.isFinite(tMs)) return false;

    if(tMs < fromMs || tMs > toMs) return false;

    return true;
  });

  if(mode==="desc")   rows.sort((a,b)=>b.ft-a.ft);
  if(mode==="asc")    rows.sort((a,b)=>a.ft-b.ft);
  if(mode==="recent") rows.sort((a,b)=>new Date(b.t)-new Date(a.t));

  renderHist(rows);
}

/* =========================
Monthly averages
========================= */
function monthNameFromIndex(i){
  const d = new Date(Date.UTC(2020, i-1, 15, 0, 0, 0));
  return fmtMonthName.format(d);
}

function computeMonthlyAveragesFromEvents(eventsNavd){
  const T = THRESH.NAVD88;
  const byYearMonth = new Map();
  const yearsSet = new Set();

  for(const p of eventsNavd){
    let y = p.y, m = p.m;
    if(!y || !m){
      const dt = new Date(p.t);
      if(Number.isNaN(dt.getTime())) continue;
      y = dt.getUTCFullYear();
      m = dt.getUTCMonth()+1;
    }
    yearsSet.add(y);

    const key = `${y}-${m}`;
    if(!byYearMonth.has(key)){
      byYearMonth.set(key,{year:y, month:m, total:0, minor:0, moderate:0, major:0});
    }
    const rec = byYearMonth.get(key);

    if(p.ft >= T.minorLow){
      rec.total++;
      if(p.ft >= T.majorLow) rec.major++;
      else if(p.ft >= T.moderateLow) rec.moderate++;
      else rec.minor++;
    }
  }

  const years = Array.from(yearsSet).sort((a,b)=>a-b);
  const result = [];

  for(let m=1;m<=12;m++){
    const rowsForMonth=[];
    for(const y of years){
      const key = `${y}-${m}`;
      rowsForMonth.push(byYearMonth.get(key) || {year:y, month:m, total:0, minor:0, moderate:0, major:0});
    }
    const n = rowsForMonth.length || 1;
    const sum = rowsForMonth.reduce((acc,r)=>{
      acc.total += r.total;
      acc.minor += r.minor;
      acc.moderate += r.moderate;
      acc.major += r.major;
      return acc;
    },{total:0, minor:0, moderate:0, major:0});

    result.push({
      month:m,
      avgTotal: sum.total / n,
      avgMinor: sum.minor / n,
      avgModerate: sum.moderate / n,
      avgMajor: sum.major / n,
      years:n
    });
  }
  return result;
}

function renderMonthAveragesTable(monthStats){
  monthAvgBody.innerHTML="";
  for(const r of monthStats){
    const tr=document.createElement("tr");
    tr.innerHTML=`
      <td><b>${monthNameFromIndex(r.month)}</b></td>
      <td>${r.avgTotal.toFixed(2)}</td>
      <td>${r.avgMinor.toFixed(2)}</td>
      <td>${r.avgModerate.toFixed(2)}</td>
      <td>${r.avgMajor.toFixed(2)}</td>
    `;
    monthAvgBody.appendChild(tr);
  }
}

function ensureMonthAvgChart(){
  if(monthAvgChart) return;
  monthAvgChart = new Chart($("monthAvgChart"),{
    type:"bar",
    data:{ labels:[], datasets:[
      {label:"Avg Minor", data:[], stack:"m", borderWidth:0, backgroundColor:"rgba(251,191,36,.85)"},
      {label:"Avg Moderate", data:[], stack:"m", borderWidth:0, backgroundColor:"rgba(251,113,133,.80)"},
      {label:"Avg Major", data:[], stack:"m", borderWidth:0, backgroundColor:"rgba(167,139,250,.80)"}
    ]},
    options:{
      responsive:true,
      maintainAspectRatio:false,
      plugins:{ legend:{position:"bottom",labels:{color:"rgba(234,240,255,.88)",font:{weight:"950"},boxWidth:16}} },
      scales:{
        x:{stacked:true,ticks:{color:"rgba(169,182,211,.9)"},grid:{color:"rgba(255,255,255,.06)"}},
        y:{stacked:true,ticks:{color:"rgba(169,182,211,.9)"},grid:{color:"rgba(255,255,255,.06)"}}
      }
    }
  });
}

function renderMonthAveragesChart(monthStats){
  ensureMonthAvgChart();
  monthAvgChart.data.labels = monthStats.map(r=>monthNameFromIndex(r.month));
  monthAvgChart.data.datasets[0].data = monthStats.map(r=>r.avgMinor);
  monthAvgChart.data.datasets[1].data = monthStats.map(r=>r.avgModerate);
  monthAvgChart.data.datasets[2].data = monthStats.map(r=>r.avgMajor);
  monthAvgChart.update();
}

function updateMonthAveragesFromHistory(){
  if(!HIGH_TIDES_NAVD.length){
    monthAvgMeta.textContent = "";
    const zeros = Array.from({length:12},(_,i)=>({
      month:i+1, avgTotal:0, avgMinor:0, avgModerate:0, avgMajor:0, years:0
    }));
    renderMonthAveragesTable(zeros);
    renderMonthAveragesChart(zeros);
    return;
  }

  const stats = computeMonthlyAveragesFromEvents(HIGH_TIDES_NAVD);
  monthAvgMeta.textContent = "";
  renderMonthAveragesTable(stats);
  renderMonthAveragesChart(stats);
}


/* =========================
LIVE: current conditions + daily range + overwrite current year bar
========================= */
async function updateLiveAndAnnualCounts(){
  // Build completed-year bars from whatever history is currently loaded
  buildAnnualArraysFromHistory_completedYears();
  renderAnnual();

  // ---- Live observed series YTD (NAVD88) ----
  const { y: curYear } = getESTParts(new Date());
  const startISO = startOfYearEST_ISO(curYear);
  const endISO   = nowISO();

  const ytd = await fetchObservedSeries({ startISO, endISO });
  if(!ytd.length) throw new Error("no live water-level data returned from USGS");

  STATE.ytdNavd  = ytd;
  STATE.lastNavd = ytd[ytd.length - 1];

  // ---- Current water level card ----
  curFtEl.textContent = toDisplayFtFromNavd(STATE.lastNavd.ft).toFixed(2);
  curMetaEl.textContent = "Updated: " + fmtESTFull(STATE.lastNavd.t);
  lastPill.textContent  = "Last updated: " + fmtESTFull(STATE.lastNavd.t);
  setStage(STATE.lastNavd.ft);

  // ---- Daily range (today) ----
  const today = sliceAfter(ytd, startOfTodayEST_ISO());
  STATE.todayNavd = today;

  if(today.length){
    const dmx = maxPoint(today), dmn = minPoint(today);
    dayMaxFtEl.textContent = toDisplayFtFromNavd(dmx.ft).toFixed(2);
    dayMinFtEl.textContent = toDisplayFtFromNavd(dmn.ft).toFixed(2);
    dayRangeMeta.textContent = `Max @ ${fmtESTFull(dmx.t)} · Min @ ${fmtESTFull(dmn.t)}`;
  }else{
    dayMaxFtEl.textContent="—";
    dayMinFtEl.textContent="—";
    dayRangeMeta.textContent="—";
  }

  // ---- Current-year flooding bar: history-based (peaks list) ----
  // NOTE: requires HIGH_TIDES_NAVD already loaded (JSON/TXT init)
  const counts = countEventsFromHistoryForYear(curYear);
  overwriteCurrentYearBarWithLiveCounts(counts);
  renderAnnual();
}

/* =========================
Timeseries update (observed + predictions)
- Observed: last 24h
- Predictions: 72h starting at next 15-min tick after last observation
========================= */
async function updateTimeseries(){
  const end = new Date();
  const start = new Date(end.getTime() - 24*3600*1000);

  // Observed: last 24h (NAVD88)
  const obs = await fetchObservedSeries({
    startISO: start.toISOString(),
    endISO: end.toISOString()
  });
  STATE.obs24Navd = obs || [];

  // Forecast: PETSS (MLLW)
  try {
    const { issuedTime, points, urlUsed } = await fetchPETSSForecast_MLLW({ hours: 48 });
    STATE.pred72Mllw = points || [];

    if (STATE.pred72Mllw.length) {
      fcNote.textContent =
        (issuedTime ? `NOAA/PETSS forecast issued: ${fmtESTFull(issuedTime)}` : "NOAA/PETSS forecast loaded") +
        ` · Source: ${urlUsed}`;
    } else {
      fcNote.textContent = `NOAA/PETSS returned no points · Source: ${urlUsed}`;
    }
  } catch (e) {
    console.error("PETSS forecast failed:", e);
    STATE.pred72Mllw = [];
    fcNote.textContent = "NOAA/PETSS forecast unavailable";
  }

  // ✅ IMPORTANT: actually render the chart + 24h range card after STATE updates
  updateTsChartFromState();
  updatePred24RangeCard();
  updateFloodOutlook48();
}



/* =========================
JSON-BACKED HISTORY (NAVD88 PEAKS)
========================= */

const PEAKS_JSON_FILE = "bivalve_peaks_navd88.json";
const PEAKS_JSON_PATH_CANDIDATES = [
  `data/${PEAKS_JSON_FILE}`,
  `./data/${PEAKS_JSON_FILE}`,
  `../data/${PEAKS_JSON_FILE}`,
  `/data/${PEAKS_JSON_FILE}`
];

let PEAKS_JSON_URL = PEAKS_JSON_PATH_CANDIDATES[0];

async function resolvePeaksJsonUrl(){
  const errs = [];
  for(const u of PEAKS_JSON_PATH_CANDIDATES){
    try{
      const res = await fetch(`${u}?v=${Date.now()}`, { cache:"no-store" });
      if(!res.ok) throw new Error(`HTTP ${res.status}`);
      const json = await res.json();
      PEAKS_JSON_URL = u;
      return { url:u, json };
    }catch(e){
      errs.push(`${u} (${e?.message || e})`);
    }
  }
  throw new Error("Could not load peaks JSON. Tried: " + errs.join(" | "));
}

function normalizePeaksJson(json){
  const arr =
    Array.isArray(json) ? json :
    Array.isArray(json?.events) ? json.events :
    Array.isArray(json?.peaks) ? json.peaks :
    Array.isArray(json?.data) ? json.data :
    [];

  const out = [];
  for(const r of arr){
    const tRaw = r?.t ?? r?.time ?? r?.timestamp ?? r?.datetime ?? r?.dateTime ?? null;
    const ftRaw = r?.ft ?? r?.value ?? r?.height ?? r?.navd88 ?? r?.navd ?? null;

    if(!tRaw) continue;

    const dt = new Date(tRaw);
    if(Number.isNaN(dt.getTime())) continue;

    const ft = Number(ftRaw);
    if(!Number.isFinite(ft)) continue;

    // Derive y/m/d if missing (your monthly stats like having these)
    const y = r?.y ?? r?.year ?? dt.getUTCFullYear();
    const m = r?.m ?? r?.month ?? (dt.getUTCMonth() + 1);
    const d = r?.d ?? r?.day ?? dt.getUTCDate();

    out.push({
      t: dt.toISOString(),
      ft,
      y, m, d,
      kind: r?.kind ?? r?.type ?? "Peak",
      source: "JSON"
    });
  }
  return out;
}

async function initJSONBackedHistory(){
  const { json } = await resolvePeaksJsonUrl();
  const peaks = normalizePeaksJson(json); // NAVD88

  // Only build live peaks if JSON does NOT already contain 2026+
  const has2026Plus = peaks.some(e => {
    const y = new Date(e.t).getUTCFullYear();
    return Number.isFinite(y) && y >= 2026;
  });

  let livePeaks = [];
  if(!has2026Plus){
    try{
      livePeaks = await buildLiveFloodPeaksSince2026();
    }catch(e){
      console.error("Live peaks build failed:", e);
      livePeaks = [];
    }
  }

  // Combine (may contain overlaps)
  const combined = [...peaks, ...livePeaks];

  /* --- HARD DEDUPE: keep max per (EST day + tide-cycle bucket) --- */
  function estParts(iso){
    const p = fmtPartsYMD.formatToParts(new Date(iso)); // TZ = Etc/GMT+5
    return {
      y: p.find(x=>x.type==="year")?.value,
      m: p.find(x=>x.type==="month")?.value,
      d: p.find(x=>x.type==="day")?.value
    };
  }

  function estHour(iso){
    const dt = new Date(iso);
    const parts = new Intl.DateTimeFormat("en-US", {
      timeZone: TZ,
      hour: "2-digit",
      hour12: false
    }).formatToParts(dt);
    return +(parts.find(x=>x.type==="hour")?.value || "0");
  }

  function tideBucket(iso){
    return estHour(iso) < 12 ? "AM" : "PM";
  }

  const bestByKey = new Map();

  for(const e of combined){
    const dt = new Date(e.t);
    if(Number.isNaN(dt.getTime())) continue;

    const ft = Number(e.ft);
    if(!Number.isFinite(ft)) continue;

    const {y,m,d} = estParts(e.t);
    if(!y || !m || !d) continue;

    const key = `${y}-${m}-${d}|${tideBucket(e.t)}`;

    const prev = bestByKey.get(key);
    if(!prev || ft > prev.ft){
      bestByKey.set(key, e);
    }
  }

  HIGH_TIDES_NAVD = Array.from(bestByKey.values());

  // Newest first
  HIGH_TIDES_NAVD.sort((a,b)=>new Date(b.t)-new Date(a.t));

  // Refresh UI that depends on HIGH_TIDES_NAVD
  applyFilter();
  updateMonthAveragesFromHistory();
  buildAnnualArraysFromHistory_completedYears();
  renderAnnual();

  if(histMeta) histMeta.textContent = "";
  if(monthAvgMeta) monthAvgMeta.textContent = "";
}



async function initTXTBackedHistory(){
  await loadDailyTidesFromTXT();
  await hydrateHistoricFromTXT();
  updateMonthAveragesFromHistory();
  buildAnnualArraysFromHistory_completedYears();
  renderAnnual();
}

      function countEventsFromHistoryForYear(year){
  const T = THRESH.NAVD88;
  let minor=0, moderate=0, major=0;

  for(const e of (HIGH_TIDES_NAVD || [])){
    const tMs = new Date(e.t).getTime();
    if(!Number.isFinite(tMs)) continue;

    // Use EST year consistency (your UI logic is EST-based)
    const { y } = getESTParts(new Date(e.t));
    if(y !== year) continue;

    const ft = +e.ft;
    if(!Number.isFinite(ft)) continue;

    if(ft >= T.majorLow) major++;
    else if(ft >= T.moderateLow) moderate++;
    else if(ft >= T.minorLow) minor++;
  }
  return { minor, moderate, major };
}




/* =========================
Boot
========================= */
/* =========================
Boot
========================= */
async function boot(){
  updateUnitsAndBadges();
  renderTopTen();

  // Alerts can run independently
 await Promise.allSettled([ initDOYCumulativeFromAPI_FAST() ]);

await Promise.allSettled([ updateAlerts() ]);


 // 1) Must load history first (HIGH_TIDES_NAVD)
const hist = await Promise.allSettled([
  initJSONBackedHistory() /* or initTXTBackedHistory() */
]);

if (hist[0].status === "rejected") {
  console.error("History init failed:", hist[0].reason);
  if (histMeta)      histMeta.textContent = "History load failed. Check /data/bivalve_peaks_navd88.json.";
  if (monthAvgMeta)  monthAvgMeta.textContent = "History load failed (monthly averages unavailable).";
}

// ✅ NEW: DOY cumulative panel (daily stats from USGS API; no TXT)




  // 2) Live counts rely on history for current-year bar overwrite
  const live = await Promise.allSettled([ updateLiveAndAnnualCounts() ]);
  if(live[0].status === "rejected"){
    console.error("Live init failed:", live[0].reason);
    stageTextEl.textContent="LIVE DATA UNAVAILABLE";
    lastPill.textContent="Last updated: —";
    curFtEl.textContent="—";
    curMetaEl.textContent="Updated: —";
  }

  // 3) Timeseries does not depend on history
  await Promise.allSettled([ updateTimeseries() ]);
}


/* =========================
Controls
========================= */
$("applyBtn").addEventListener("click", applyFilter);

$("resetBtn").addEventListener("click", ()=>{
  minElevEl.value = THRESH[DISPLAY_DATUM].minorLow.toFixed(2);
  maxElevEl.value = "";
  if(fromDateEl) fromDateEl.value = "";
  if(toDateEl)   toDateEl.value = "";
  sortModeEl.value = "desc";
  applyFilter();
});

datumBtn.addEventListener("click", ()=>{
const oldDatum = DISPLAY_DATUM;

// flip datum happens later, so DO NOT refresh yet

  

  const vMin = parseFloat(minElevEl.value);
  const vMax = parseFloat(maxElevEl.value);

  function toNavdFromOldDisplay(v){
    if(!Number.isFinite(v)) return null;
    return (oldDatum==="MLLW") ? mllwToNavd(v) : v;
  }

  // convert current inputs -> NAVD (stable internal datum)
  const navdMin = toNavdFromOldDisplay(vMin);
  const navdMax = toNavdFromOldDisplay(vMax);

  // flip datum
  DISPLAY_DATUM = (DISPLAY_DATUM==="MLLW") ? "NAVD88" : "MLLW";
  refreshDOYAfterDatumToggle(); // ✅ recompute DOY + YTD in the new datum


  function toNewDisplayFromNavd(navd){
    if(navd===null || !Number.isFinite(navd)) return null;
    return (DISPLAY_DATUM==="MLLW") ? navdToMllw(navd) : navd;
  }

  // write inputs back in the NEW display datum
  const newMin = toNewDisplayFromNavd(navdMin);
  const newMax = toNewDisplayFromNavd(navdMax);

  minElevEl.value = (newMin===null)
    ? THRESH[DISPLAY_DATUM].minorLow.toFixed(2)
    : newMin.toFixed(2);

  maxElevEl.value = (newMax===null) ? "" : newMax.toFixed(2);

  // refresh everything that depends on DISPLAY_DATUM
  updateUnitsAndBadges();
  renderTopTen();
  applyFilter();
  updateMonthAveragesFromHistory();
  renderAnnual();

  // refresh live cards (stored internally as NAVD or MLLW where noted)
  if(STATE.lastNavd){
    curFtEl.textContent = toDisplayFtFromNavd(STATE.lastNavd.ft).toFixed(2);
    setStage(STATE.lastNavd.ft);
  }

  if(STATE.todayNavd && STATE.todayNavd.length){
    const dmx = maxPoint(STATE.todayNavd), dmn = minPoint(STATE.todayNavd);
    dayMaxFtEl.textContent = toDisplayFtFromNavd(dmx.ft).toFixed(2);
    dayMinFtEl.textContent = toDisplayFtFromNavd(dmn.ft).toFixed(2);
  } else {
    dayMaxFtEl.textContent = "—";
    dayMinFtEl.textContent = "—";
  }

  updatePred24RangeCard();
  updateTsChartFromState();
  updateFloodOutlook48();
});




/* Start */
boot().catch(err=>{
  console.error(err);
  stageTextEl.textContent="LIVE DATA UNAVAILABLE";
  lastPill.textContent="Last updated: —";
});

/* Auto-refresh (LIVE only — don’t reload TXT every time) */
setInterval(async ()=>{
  try{
    await Promise.allSettled([
      updateAlerts(),
      updateLiveAndAnnualCounts(),
      updateTimeseries()
    ]);
  }catch(e){
    console.error(e);
  }
}, 5*60*1000);

    

    </script>
</body>
</html>
