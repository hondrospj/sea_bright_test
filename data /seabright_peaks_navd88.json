#!/usr/bin/env node
/**
 * Sea Bright (SBIN4) crest-anchored NAVD88 peaks cache builder
 *
 * Crest clock = LOCAL MAXIMA in NWPS FORECAST series (stageflow/forecast)
 * Observed crest height = MAX observed within ±2h of forecast crest,
 * but SKIP if no obs within ±1h (same rule you use now).
 *
 * Writes: data/seabright_peaks_navd88.json
 */

const fs = require("fs");
const path = require("path");

const CACHE_PATH = path.join(__dirname, "..", "data", "seabright_peaks_navd88.json");

// --- Sea Bright constants ---
const GAUGE_ID = "SBIN4";

// Sea Bright: NAVD88 = MLLW - 2.10
const NAVD_MINUS_MLLW_FT = -2.10;
function mllwToNavd(ftMllw) { return ftMllw + NAVD_MINUS_MLLW_FT; }

// Match your Bivalve behavior
const PEAK_MIN_SEP_MINUTES = 300;
const BUFFER_HOURS = 12;

const CREST_WINDOW_HOURS = 2;   // search max within ±2h
const REQUIRE_WITHIN_HOURS = 1; // must have obs within ±1h else skip

const METHOD = "nwps_crest_anchored_v1";

const NWPS_BASE = `https://api.water.noaa.gov/nwps/v1/gauges/${GAUGE_ID}`;
const OBS_URL   = `${NWPS_BASE}/stageflow/observed`;
const FCST_URL  = `${NWPS_BASE}/stageflow/forecast`;

function die(msg) { console.error(msg); process.exit(1); }

function loadJSON(p) {
  if (!fs.existsSync(p)) die(`Missing cache file: ${p}`);
  return JSON.parse(fs.readFileSync(p, "utf8"));
}
function saveJSON(p, obj) {
  fs.writeFileSync(p, JSON.stringify(obj, null, 2) + "\n", "utf8");
}
function isoNow() { return new Date().toISOString(); }
function addHoursISO(iso, hours) {
  const t = new Date(iso).getTime();
  if (!Number.isFinite(t)) return null;
  return new Date(t + hours * 3600 * 1000).toISOString();
}
function roundFt(x) { return Math.round(x * 1000) / 1000; }

function classifyNAVD(ft, T) {
  let type = "Below";
  if (ft >= T.majorLow) type = "Major";
  else if (ft >= T.moderateLow) type = "Moderate";
  else if (ft >= T.minorLow) type = "Minor";
  return type;
}

async function fetchJson(url) {
  const res = await fetch(url, { headers: { "User-Agent": "seabright-peaks-cache/1.0" } });
  if (!res.ok) throw new Error(`Fetch failed ${res.status} for ${url}`);
  return res.json();
}

// Try multiple likely NWPS shapes; normalize to [{t, ftMllw}]
function extractNWPSPoints_MLLW(j) {
  const candidates = [];

  // common
  if (Array.isArray(j?.data)) candidates.push(j.data);

  // sometimes nested
  if (Array.isArray(j?.forecast?.data)) candidates.push(j.forecast.data);
  if (Array.isArray(j?.observed?.data)) candidates.push(j.observed.data);

  // timeseries containers
  if (Array.isArray(j?.timeseries)) {
    for (const ts of j.timeseries) {
      if (Array.isArray(ts?.data)) candidates.push(ts.data);
      if (Array.isArray(ts?.points)) candidates.push(ts.points);
    }
  }

  const out = [];
  for (const arr of candidates) {
    for (const d of arr) {
      const t = d.validTime || d.valid_time || d.time || d.dateTime || d.timestamp;
      const v = d.primary ?? d.stage ?? d.value ?? d.v ?? d.primaryValue;
      if (!t) continue;
      const ft = Number(v);
      const ms = new Date(t).getTime();
      if (!Number.isFinite(ms) || !Number.isFinite(ft)) continue;
      out.push({ t: new Date(ms).toISOString(), ftMllw: ft });
    }
  }

  out.sort((a,b)=> new Date(a.t) - new Date(b.t));

  // de-dupe by time
  const dedup = [];
  let last = null;
  for (const p of out) {
    if (p.t === last) continue;
    dedup.push(p);
    last = p.t;
  }
  return dedup;
}

// Find local maxima in forecast (MLLW), then apply min separation
function findForecastCrests(points, minSepMinutes) {
  if (!points || points.length < 3) return [];
  const cands = [];

  for (let i=1; i<points.length-1; i++) {
    const a = points[i-1], b = points[i], c = points[i+1];
    if (b.ftMllw >= a.ftMllw && b.ftMllw >= c.ftMllw) {
      if (!(b.ftMllw === a.ftMllw && b.ftMllw === c.ftMllw)) cands.push(b);
    }
  }
  if (!cands.length) return [];

  const minSepMs = minSepMinutes * 60 * 1000;
  const kept = [];
  let cur = cands[0];

  for (let i=1; i<cands.length; i++) {
    const p = cands[i];
    const pt = new Date(p.t).getTime();
    const ct = new Date(cur.t).getTime();
    if (Number.isFinite(pt) && Number.isFinite(ct) && (pt - ct) <= minSepMs) {
      if (p.ftMllw > cur.ftMllw) cur = p;
    } else {
      kept.push(cur);
      cur = p;
    }
  }
  kept.push(cur);

  return kept.map(x => ({ crest: x.t })); // crest clock list
}

// Build crest-anchored observed events in NAVD88 (same event schema as your Bivalve cache)
function buildCrestAnchoredEvents({ observed, crests, thresholdsNAVD88 }) {
  const out = [];
  if (!observed.length || !crests.length) return out;

  const pts = observed.slice().sort((a,b)=> new Date(a.t) - new Date(b.t));
  const w2 = CREST_WINDOW_HOURS * 3600 * 1000;
  const w1 = REQUIRE_WITHIN_HOURS * 3600 * 1000;

  let left = 0;

  for (const h of crests) {
    const crestISO = h.crest;
    const crestMs = new Date(crestISO).getTime();
    if (!Number.isFinite(crestMs)) continue;

    while (left < pts.length) {
      const tMs = new Date(pts[left].t).getTime();
      if (!Number.isFinite(tMs) || tMs < crestMs - w2) left++;
      else break;
    }

    let i = left;
    let hasWithin1h = false;
    let best = null;

    while (i < pts.length) {
      const tMs = new Date(pts[i].t).getTime();
      if (!Number.isFinite(tMs)) { i++; continue; }
      if (tMs > crestMs + w2) break;

      const dt = Math.abs(tMs - crestMs);
      if (dt <= w1) hasWithin1h = true;

      if (!best || pts[i].ftMllw > best.ftMllw) best = pts[i];
      i++;
    }

    if (!hasWithin1h) continue;
    if (!best) continue;

    const navd = mllwToNavd(best.ftMllw);

    out.push({
      t: best.t,                         // observed timestamp of max
      ft: roundFt(navd),                 // NAVD88 feet
      type: classifyNAVD(navd, thresholdsNAVD88),
      crest: new Date(crestISO).toISOString(), // forecast crest time
      kind: "CrestHigh"
    });
  }

  return out;
}

function mergeEvents(existing, incoming) {
  const map = new Map();
  for (const e of existing) map.set(e.crest, e); // crest key like your Bivalve scheme
  for (const e of incoming) {
    if (!map.has(e.crest)) map.set(e.crest, e);
    else {
      // keep higher ft if duplicate crest
      const cur = map.get(e.crest);
      if (e.ft > cur.ft) map.set(e.crest, e);
    }
  }
  return Array.from(map.values()).sort((a,b)=> new Date(a.t) - new Date(b.t));
}

async function main() {
  const cache = loadJSON(CACHE_PATH);

  const THRESH_NAVD88 = cache?.thresholdsNAVD88;
  if (!THRESH_NAVD88) die("Missing thresholdsNAVD88 in cache JSON.");

  if (cache.method !== METHOD) {
    console.log(`Method changed (${cache.method || "none"} -> ${METHOD}). Clearing events for clean rebuild.`);
    cache.method = METHOD;
    cache.events = [];
  }

  const last = cache.lastProcessedISO || "2026-01-01T00:00:00.000Z";
  const startISO = addHoursISO(last, -BUFFER_HOURS) || last;
  const endISO = isoNow();

  console.log(`Fetching NWPS observed: ${OBS_URL}`);
  const obsJ = await fetchJson(OBS_URL);
  const observedAll = extractNWPSPoints_MLLW(obsJ);

  console.log(`Fetching NWPS forecast: ${FCST_URL}`);
  const fcJ = await fetchJson(FCST_URL);
  const forecastAll = extractNWPSPoints_MLLW(fcJ);

  // Only use crests in [startISO, endISO]
  const sMs = new Date(startISO).getTime();
  const eMs = new Date(endISO).getTime();

  const forecastWindow = forecastAll.filter(p => {
    const ms = new Date(p.t).getTime();
    return Number.isFinite(ms) && ms >= sMs && ms <= eMs;
  });
  const observedWindow = observedAll.filter(p => {
    const ms = new Date(p.t).getTime();
    return Number.isFinite(ms) && ms >= sMs && ms <= eMs;
  });

  const crestList = findForecastCrests(forecastWindow, PEAK_MIN_SEP_MINUTES);

  const newEvents = buildCrestAnchoredEvents({
    observed: observedWindow,
    crests: crestList,
    thresholdsNAVD88: THRESH_NAVD88
  });

  cache.events = mergeEvents(cache.events || [], newEvents);
  cache.lastProcessedISO = endISO;
  cache.gaugeId = GAUGE_ID;
  cache.datum = "NAVD88";
  cache.peakMinSepMinutes = cache.peakMinSepMinutes || PEAK_MIN_SEP_MINUTES;

  saveJSON(CACHE_PATH, cache);
  console.log(`Wrote ${cache.events.length} events -> data/seabright_peaks_navd88.json`);
}

main().catch(err => {
  console.error(err);
  process.exit(1);
});
